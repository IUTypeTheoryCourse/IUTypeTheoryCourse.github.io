<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>3&nbsp;Lecture notes</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {document.write('<scr' + 'ipt type="text/javascript" src="MathJax/MathJax.js?config=default"></scr' + 'ipt>');})();
</script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">B629 Spring 2023 &ndash; Proofs as Programs</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Course_calendar.html" class="tocviewlink" data-pltdoc="x">Course calendar</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lecture notes</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="Worksheets.html" class="tocviewlink" data-pltdoc="x">Worksheets</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>3&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lecture notes</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">3.1&nbsp;</td><td><a href="#%28part._.Propositional_logic%29" class="tocviewlink" data-pltdoc="x">Propositional logic</a></td></tr><tr><td align="right">3.2&nbsp;</td><td><a href="#%28part._.Designing_tactics%29" class="tocviewlink" data-pltdoc="x">Designing tactics</a></td></tr><tr><td align="right">3.3&nbsp;</td><td><a href="#%28part._.Elaboration%29" class="tocviewlink" data-pltdoc="x">Elaboration</a></td></tr><tr><td align="right">3.4&nbsp;</td><td><a href="#%28part._.The_simply-typed_lambda_calculus%29" class="tocviewlink" data-pltdoc="x">The simply-<wbr></wbr>typed lambda calculus</a></td></tr><tr><td align="right">3.5&nbsp;</td><td><a href="#%28part._.Normalization_by_evaluation%29" class="tocviewlink" data-pltdoc="x">Normalization by evaluation</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Propositional_logic%29" class="tocsubseclink" data-pltdoc="x">Propositional logic</a></td></tr><tr><td><span class="tocsublinknumber">3.1.1<tt>&nbsp;</tt></span><a href="#%28part._.The_syllabus%29" class="tocsubseclink" data-pltdoc="x">The syllabus</a></td></tr><tr><td><span class="tocsublinknumber">3.1.2<tt>&nbsp;</tt></span><a href="#%28part._.Philosophical_foundations_of_type_theory%29" class="tocsubseclink" data-pltdoc="x">Philosophical foundations of type theory</a></td></tr><tr><td><span class="tocsublinknumber">3.1.3<tt>&nbsp;</tt></span><a href="#%28part._.Classical_propositional_logic__semantics%29" class="tocsubseclink" data-pltdoc="x">Classical propositional logic:<span class="mywbr"> &nbsp;</span> semantics</a></td></tr><tr><td><span class="tocsublinknumber">3.1.4<tt>&nbsp;</tt></span><a href="#%28part._.Natural_deduction%29" class="tocsubseclink" data-pltdoc="x">Natural deduction</a></td></tr><tr><td><span class="tocsublinknumber">3.1.5<tt>&nbsp;</tt></span><a href="#%28part._.Classical_propositional_logic__proof_system%29" class="tocsubseclink" data-pltdoc="x">Classical propositional logic:<span class="mywbr"> &nbsp;</span> proof system</a></td></tr><tr><td><span class="tocsublinknumber">3.1.6<tt>&nbsp;</tt></span><a href="#%28part._.Intuitionistic_propositional_logic%29" class="tocsubseclink" data-pltdoc="x">Intuitionistic propositional logic</a></td></tr><tr><td><span class="tocsublinknumber">3.1.7<tt>&nbsp;</tt></span><a href="#%28part._.The_.B.H.K_interpretation%29" class="tocsubseclink" data-pltdoc="x">The BHK interpretation</a></td></tr><tr><td><span class="tocsublinknumber">3.1.8<tt>&nbsp;</tt></span><a href="#%28part._.Intuitionistic_propositional_logic__proof_system%29" class="tocsubseclink" data-pltdoc="x">Intuitionistic propositional logic:<span class="mywbr"> &nbsp;</span> proof system</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.Designing_tactics%29" class="tocsubseclink" data-pltdoc="x">Designing tactics</a></td></tr><tr><td><span class="tocsublinknumber">3.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Tactics%29" class="tocsubseclink" data-pltdoc="x">Tactics</a></td></tr><tr><td><span class="tocsublinknumber">3.2.2<tt>&nbsp;</tt></span><a href="#%28part._.Propositions_in_.Racket%29" class="tocsubseclink" data-pltdoc="x">Propositions in Racket</a></td></tr><tr><td><span class="tocsublinknumber">3.2.3<tt>&nbsp;</tt></span><a href="#%28part._.Tactics_in_.Racket%29" class="tocsubseclink" data-pltdoc="x">Tactics in Racket</a></td></tr><tr><td><span class="tocsublinknumber">3.2.4<tt>&nbsp;</tt></span><a href="#%28part._.Our_first_example__variable_references%29" class="tocsubseclink" data-pltdoc="x">Our first example:<span class="mywbr"> &nbsp;</span> variable references</a></td></tr><tr><td><span class="tocsublinknumber">3.2.5<tt>&nbsp;</tt></span><a href="#%28part._.Examples__conversion_and_annotation%29" class="tocsubseclink" data-pltdoc="x">Examples:<span class="mywbr"> &nbsp;</span> conversion and annotation</a></td></tr><tr><td><span class="tocsublinknumber">3.2.6<tt>&nbsp;</tt></span><a href="#%28part._.Check_versus_infer_and_solving_unknowns%29" class="tocsubseclink" data-pltdoc="x">Check versus infer and solving unknowns</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._.Elaboration%29" class="tocsubseclink" data-pltdoc="x">Elaboration</a></td></tr><tr><td><span class="tocsublinknumber">3.3.1<tt>&nbsp;</tt></span><a href="#%28part._.What_%29" class="tocsubseclink" data-pltdoc="x">What?</a></td></tr><tr><td><span class="tocsublinknumber">3.3.2<tt>&nbsp;</tt></span><a href="#%28part._.De.Bruijn_levels%29" class="tocsubseclink" data-pltdoc="x">De<span class="mywbr"> &nbsp;</span>Bruijn levels</a></td></tr><tr><td><span class="tocsublinknumber">3.3.3<tt>&nbsp;</tt></span><a href="#%28part._.Elaborating_tactics%29" class="tocsubseclink" data-pltdoc="x">Elaborating tactics</a></td></tr><tr><td><span class="tocsublinknumber">3.4<tt>&nbsp;</tt></span><a href="#%28part._.The_simply-typed_lambda_calculus%29" class="tocsubseclink" data-pltdoc="x">The simply-<wbr></wbr>typed lambda calculus</a></td></tr><tr><td><span class="tocsublinknumber">3.4.1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Curry-.Howard_correspondence%29" class="tocsubseclink" data-pltdoc="x">The Curry-<wbr></wbr>Howard correspondence</a></td></tr><tr><td><span class="tocsublinknumber">3.4.2<tt>&nbsp;</tt></span><a href="#%28part._.Type_theory_notation%29" class="tocsubseclink" data-pltdoc="x">Type theory notation</a></td></tr><tr><td><span class="tocsublinknumber">3.4.3<tt>&nbsp;</tt></span><a href="#%28part._.Bidirectional_typing%29" class="tocsubseclink" data-pltdoc="x">Bidirectional typing</a></td></tr><tr><td><span class="tocsublinknumber">3.4.4<tt>&nbsp;</tt></span><a href="#%28part._.Checking_our_concrete_syntax%29" class="tocsubseclink" data-pltdoc="x">Checking our concrete syntax</a></td></tr><tr><td><span class="tocsublinknumber">3.5<tt>&nbsp;</tt></span><a href="#%28part._.Normalization_by_evaluation%29" class="tocsubseclink" data-pltdoc="x">Normalization by evaluation</a></td></tr><tr><td><span class="tocsublinknumber">3.5.1<tt>&nbsp;</tt></span><a href="#%28part._.Deciding_equivalence%29" class="tocsubseclink" data-pltdoc="x">Deciding equivalence</a></td></tr><tr><td><span class="tocsublinknumber">3.5.2<tt>&nbsp;</tt></span><a href="#%28part._.Data_definitions_for_.S.T.L.C%29" class="tocsubseclink" data-pltdoc="x">Data definitions for STLC</a></td></tr><tr><td><span class="tocsublinknumber">3.5.3<tt>&nbsp;</tt></span><a href="#%28part._.Building_terms_with_.De.Bruijn_levels__or__continuation_.H.O.A.S_%29" class="tocsubseclink" data-pltdoc="x">Building terms with De<span class="mywbr"> &nbsp;</span>Bruijn levels (or:<span class="mywbr"> &nbsp;</span> continuation HOAS)</a></td></tr><tr><td><span class="tocsublinknumber">3.5.4<tt>&nbsp;</tt></span><a href="#%28part._.The_evaluator%29" class="tocsubseclink" data-pltdoc="x">The evaluator</a></td></tr><tr><td><span class="tocsublinknumber">3.5.5<tt>&nbsp;</tt></span><a href="#%28part._.Normal_forms%29" class="tocsubseclink" data-pltdoc="x">Normal forms</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.7.0.8</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Course_calendar.html" title="backward to &quot;2 Course calendar&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;B629 Spring 2023 -- Proofs as Programs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Assignments.html" title="forward to &quot;4 Assignments&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>3<tt>&nbsp;</tt><a name="(part._.Lecture_notes)"></a>Lecture notes</h3><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Propositional_logic%29" class="toclink" data-pltdoc="x">3.1<span class="hspace">&nbsp;</span>Propositional logic</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Designing_tactics%29" class="toclink" data-pltdoc="x">3.2<span class="hspace">&nbsp;</span>Designing tactics</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Elaboration%29" class="toclink" data-pltdoc="x">3.3<span class="hspace">&nbsp;</span>Elaboration</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.The_simply-typed_lambda_calculus%29" class="toclink" data-pltdoc="x">3.4<span class="hspace">&nbsp;</span>The simply-typed lambda calculus</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Normalization_by_evaluation%29" class="toclink" data-pltdoc="x">3.5<span class="hspace">&nbsp;</span>Normalization by evaluation</a></p></td></tr></table><h4>3.1<tt>&nbsp;</tt><a name="(part._.Propositional_logic)"></a>Propositional logic</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}
\newcommand{\fst}[1]{\mathsf{fst\ } #1}
\newcommand{\snd}[1]{\mathsf{snd\ } #1}</div></p><h5>3.1.1<tt>&nbsp;</tt><a name="(part._.The_syllabus)"></a>The syllabus</h5><p>Go over the premise of the course and go over the beats of the course.
All of this content is in the syllabus. Have you read the syllabus? You
should read the syllabus. If you&rsquo;re reading this paragraph, you should
be reading the syllabus instead.</p><h5>3.1.2<tt>&nbsp;</tt><a name="(part._.Philosophical_foundations_of_type_theory)"></a>Philosophical foundations of type theory</h5><p>The first rule of type theory is you don&rsquo;t ask what a type is.</p><p>In set theory, when we say a statement like <span class="math">2 \in \mathbb{N}</span>, you&rsquo;re
making a statement about <span class="math">\mathbb{N}</span> &#8212;<wbr></wbr> we postulated the existence of
this inductive set with infinitely many elements, and however we chose to
represent <span class="math">2</span> was part of that inductively defined set.</p><p>In type theory, the definition of <span class="math">\mathbb{N}</span> looks a lot more like a
description: we add two rules to our theory,</p><p><div class="math">\ir{}{}{\Gamma \vdash \mathrm{zero} : \mathbb{N}} ~~
\ir{}{\Gamma \vdash m : \mathbb{N}}{\Gamma \vdash \mathrm{suc}\ m : \mathbb{N}}</div></p><p>both of which describe what <span style="font-style: italic">is</span> a natural number.</p><p>Don&rsquo;t worry about what these mean yet, but you can read it as "under any context,
zero is a natural number", and "if under some context, <span class="math">m</span> is a natural number,
then <span class="math">\mathrm{suc\ } m</span> is a natural number".</p><p>When we say that <span class="math">2 : \mathbb{N}</span>, then, we&rsquo;re saying that
<span class="math">\mathrm{suc\ (suc\ zero)} : \mathbb{N}</span>, which makes a statement about <span class="math">2</span>.</p><p>This is useful because in set theory, the intuition is you&rsquo;ve constructed an
infinitely large set of things, and to check membership you just traverse that
infinite set. Computers are really bad at doing anything that&rsquo;s infinite.
(Obviously, there are ways of axiomatizing set theory that avoid this. The point
is that the philosophy of type theory is more compatible with computer-aided
proof.)</p><h5>3.1.3<tt>&nbsp;</tt><a name="(part._.Classical_propositional_logic__semantics)"></a>Classical propositional logic: semantics</h5><p><div class="SIntrapara"><span style="font-weight: bold">Definition:</span> Propositional logic is defined by the grammar:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td align="right" valign="baseline"><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">prop-expr</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">var</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktVar">prop-expr</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktVar">prop-expr</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktVar">prop-expr</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8744;</span><span class="hspace">&nbsp;</span><span class="RktVar">prop-expr</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktVar">prop-expr</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8594;</span><span class="hspace">&nbsp;</span><span class="RktVar">prop-expr</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">&#172;</span><span class="hspace">&nbsp;</span><span class="RktVar">prop-expr</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">where <span class="stt">var</span> is some set of atomic symbols representing the variables.</div></p><p><div class="SIntrapara">Classical propositional logic deals with notions of "true" and "false", and the
semantics of it are truth-tables. As an example:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td align="center" style="border-bottom: 1px solid black;"><p><span class="math">A</span></p></td><td align="center" style="border-bottom: 1px solid black;"><p><span class="math">B</span></p></td><td align="center" style="border-bottom: 1px solid black;"><p><span class="math">A \to B</span></p></td></tr><tr><td align="center"><p><span class="math">\mathsf{T}</span></p></td><td align="center"><p><span class="math">\mathsf{T}</span></p></td><td align="center"><p><span class="math">\mathsf{T}</span></p></td></tr><tr><td align="center"><p><span class="math">\mathsf{T}</span></p></td><td align="center"><p><span class="math">\mathsf{F}</span></p></td><td align="center"><p><span class="math">\mathsf{F}</span></p></td></tr><tr><td align="center"><p><span class="math">\mathsf{F}</span></p></td><td align="center"><p><span class="math">\mathsf{T}</span></p></td><td align="center"><p><span class="math">\mathsf{T}</span></p></td></tr><tr><td align="center"><p><span class="math">\mathsf{F}</span></p></td><td align="center"><p><span class="math">\mathsf{F}</span></p></td><td align="center"><p><span class="math">\mathsf{T}</span></p></td></tr></table></div><div class="SIntrapara">where each truth value has a different meaning for each propositional connective.
(We went over each connective, and worked some examples.)</div></p><p><span style="font-weight: bold">Definition:</span> A <span style="font-style: italic">valuation</span> is a function
<span class="math">v : \mathsf{Var} \to \{\mathsf{T}, \mathsf{F}\}</span> that assigns meaning to each
variable. Given a valuation <span class="math">v</span> and a <span class="stt">prop-expr</span> <span class="math">e</span>, we write
<span class="math">\semantics{e}_v</span> to mean "the meaning of <span class="math">e</span> under the valuation <span class="math">v</span>".</p><p>We define the meaning of <span class="math">\semantics{e}_v</span> recursively for each connective:
<div class="math">\begin{align*}
  \semantics{X}_v &amp;= v(X), \mathrm{when\ } X \in \mathsf{Var} \\
  \semantics{X \land Y}_v &amp;= \semantics{X}_v \land \semantics{Y}_v \\
  \semantics{X \lor Y}_v &amp;= \semantics{X}_v \lor \semantics{Y}_v \\
  \semantics{X \to Y}_v &amp;= \semantics{X}_v \to \semantics{Y}_v \\
  \semantics{\neg X}_v &amp;= \neg \semantics{X}_v
\end{align*}</div>
where each connective on booleans is defined as usual.</p><p><span style="font-weight: bold">Definition:</span> A <span class="stt">prop-expr</span> <span class="math">e</span> is a <span style="font-style: italic">tautology</span> if
for all valuations <span class="math">v</span>, <span class="math">\semantics{e}_v = \mathsf{T}</span>.</p><p><span style="font-weight: bold">Definition:</span> <span class="math">e</span> is <span style="font-style: italic">satisfiable</span> if there is a valuation
<span class="math">v</span> such that <span class="math">\semantics{e}_v = \mathsf{T}</span>.</p><p><span style="font-weight: bold">Definition:</span> <span class="math">e</span> is a <span style="font-style: italic">contradiction</span> if there is no valuation
<span class="math">v</span> such that <span class="math">\semantics{e}_v = \mathsf{T}</span>, or in other words, if for
all valuations <span class="math">v</span>, <span class="math">\semantics{e}_v = \mathsf{F}</span>.</p><h5>3.1.4<tt>&nbsp;</tt><a name="(part._.Natural_deduction)"></a>Natural deduction</h5><p>In H241 (note: not C241), M384, et cetera, you would have been exposed to Fitch-style
natural deduction proofs.
We will not be doing those, instead opting for Gentzen-style natural deduction.</p><p>Natural deduction systems are comprised of <span style="font-style: italic">inference rules</span>, which look
like this:
<div class="math">\ir{}{\mathrm{assumption\ 1} ~~~ \mathrm{assumption\ 2} ~~~ \ldots ~~~ \mathrm{assumption\ } n}{\mathrm{consequent}}</div>
where everything above the line is something we already know, and the single thing below
the line is something we get as a result.</p><p><div class="SIntrapara">All of our connectives will have one of four (or five) types of associated rules:
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">Formation:</span> How to form a proposition syntactically. For example, given that <span class="math">A</span> is a
proposition and <span class="math">B</span> is a proposition, then <span class="math">A \to B</span> is a proposition. This effectively describes
the grammar of our logic.</p></li><li><p><span style="font-weight: bold">Introduction:</span> How to construct a proof of a given proposition. For example,
given that we have a proof of <span class="math">A</span> and a proof of <span class="math">B</span>, then we can construct a proof of <span class="math">A \land B</span>.</p></li><li><p><span style="font-weight: bold">Elimination:</span> How to get things from a proof of a given proposition. For example, given that
we have a proof of <span class="math">A \land B</span>, we can get a proof of <span class="math">B</span>.</p></li><li><p><span style="font-weight: bold">Computation:</span> We will discuss this later in the course.</p></li><li><p><span style="font-weight: bold">Uniqueness:</span> We will discuss this later in the course.</p></li></ul></div></p><h5>3.1.5<tt>&nbsp;</tt><a name="(part._.Classical_propositional_logic__proof_system)"></a>Classical propositional logic: proof system</h5><p>The formation rules are effectively the same as our grammar for <span class="stt">prop-expr</span> in Exercise 1, and will
be ommitted for now, but, for example, they look like this:
<div class="math">\ir{(\land_{\mathrm{form}})}{A \mathrm{\ prop} ~~~ B \mathrm{\ prop}}{A \land B \mathrm{\ prop}} ~~~
\ir{(\bot_{\mathrm{form}})}{}{\bot \mathrm{\ prop}}</div></p><p>Implication is by far the most complex of our connectives, as with our current formulation of inference
rules, we have no good way of stating a Gentzen-style rule for <span class="math">\to_\mathrm{intro}</span>.
So, we will state elimination first:
<div class="math">\ir{(\to_{\mathrm{elim}})}{A \to B ~~~ A}{B}</div>
This is often called "modus ponens", and it says that if <span class="math">A</span> implies <span class="math">B</span>, and also <span class="math">A</span>, then we have
<span class="math">B</span>.</p><p>Implication introduction requires more things in our proof system. Intuitively, <span class="math">A \to B</span> is true if,
when we assume <span class="math">A</span>, then we can derive <span class="math">B</span>. We don&rsquo;t have any notion of "assuming" in natural deduction
yet, so we need to add some extra things to our system.</p><p>Our introduction rule therefore looks like this:
<div class="math">\ir{(\to_{\mathrm{intro}})}
   {\begin{matrix}
      \ir{}{}{A} \\
      \vdots \\
      B
    \end{matrix}}
   {A \to B}</div>
where the <span class="math">\vdots</span> represents a <span style="font-style: italic">hypothetical derivation</span>. We will be revisiting this very soon.</p><p>This can be read as "we assume <span class="math">A</span>, and then derive <span class="math">B</span>" means that "if <span class="math">A</span>, then <span class="math">B</span>".</p><p>For conjunction, the inference rules are:
<div class="math">\ir{(\land_{\mathrm{intro}})}{A ~~~ B}{A \land B} ~~~
\ir{(\land_{\mathrm{elim}0})}{A \land B}{A} ~~~
\ir{(\land_{\mathrm{elim}1})}{A \land B}{B}</div>
which are relatively straightforward to reason about: if both <span class="math">A</span> and <span class="math">B</span>, then <span class="math">A \land B</span>,
and if <span class="math">A \land B</span>, then both <span class="math">A</span> and <span class="math">B</span>.</p><p>For disjunction, the inference rules are:
<div class="math">\ir{(\lor_{\mathrm{intro}0})}{A}{A \lor B} ~~~
\ir{(\lor_{\mathrm{intro}1})}{B}{A \lor B} ~~~
\ir{(\lor_{\mathrm{elim}})}{A \lor B ~~~ A \to C ~~~ B \to C}{C}</div>
which require a bit more justification. If <span class="math">A</span>, then obviously <span class="math">A \lor B</span>, and the same for
<span class="math">B</span> then <span class="math">A \lor B</span>.</p><p>For negation, we <span style="font-style: italic">define</span> <span class="math">\neg A</span> to be <span class="math">A \to \bot</span> (where that symbol is read as
"bottom"). This is the first serious departure from most expositions of propositional logic, so
make a note of it.</p><p><span class="math">\bot</span> intentionally does not have an introduction rule, as it represents a contradiction.
Note that, with this definition, we can prove the <span style="font-style: italic">law of non-contradiction</span>: that
<span class="math">\neg (A \land \neg A)</span>:
<div class="math">\ir{(\to_{\mathrm{elim}})}
   {\ir{(\land_{\mathrm{elim}1})}{A \land (A \to \bot)}{A \to \bot} ~~~
    \ir{(\land_{\mathrm{elim}0})}{A \land (A \to \bot)}{A}}
   {\bot}</div>
(noting that I implicitly use implication introduction for simplicity.)</p><p>We have two rules for dealing with <span class="math">\bot</span>:
<div class="math">\ir{(\bot_{\mathrm{elim}})}{\bot}{A} ~~~
\ir{(\mathsf{DNE})}{\neg \neg A}{A}</div>
referred to as the principle of explosion/ex falso, and double-negation elimination, respectively.
In essence, this states that if we can prove <span class="math">\bot</span>, we can prove anything. Double-negation
should seem intuitively sensible under the Boolean interpretation.</p><h5>3.1.6<tt>&nbsp;</tt><a name="(part._.Intuitionistic_propositional_logic)"></a>Intuitionistic propositional logic</h5><p>We exposited the proof system for classical propositional logic, in which the truth
values correspond to the Boolean semantics, last lecture.</p><p>We will not be discussing the semantics of IPL: if you are interested, you should look
at Kripke models and realizability. (See LACI, 2.9)</p><p>The philosophical foundation for constructive mathematics, the primary topic of this course, is
that if something is true, you should be able to hand me a witness to that truth. This is based
in the notion of intuitionism, which says, in the loosest sense, that what is true is what you
can convince me is true.</p><p>If we downplay the notion of objective truth and whether or not our semantics can show if something
is a tautology, we can instead reason more about what proofs <span style="font-style: italic">are</span>.</p><h5>3.1.7<tt>&nbsp;</tt><a name="(part._.The_.B.H.K_interpretation)"></a>The BHK interpretation</h5><p>The Brouwer-Heyting-Kolmogorov (BHK interpretation) is a way of assigning what a proof is &#8212;<wbr></wbr> as in,
the BHK interpretation of a formula is a kind of object you can hand to me to discern whether the
formula is true or not.</p><p><div class="SIntrapara"><span style="font-weight: bold">Definition:</span> We define the BHK interpretation of a formula inductively on connectives:
</div><div class="SIntrapara"><ul><li><p><span class="math">X \to Y</span> is interpreted as a function which, given a proof of <span class="math">X</span>, produces a proof of <span class="math">Y</span>.</p></li><li><p><span class="math">X \land Y</span> is interpreted as a pair <span class="math">(a, b)</span>, where <span class="math">a</span> is a proof of <span class="math">X</span> and <span class="math">b</span> is a proof
of <span class="math">Y</span>.</p></li><li><p><span class="math">X \lor Y</span> is either <span class="math">(0, a)</span> where <span class="math">a</span> is a proof of ${X}, or <span class="math">(1, b)</span> where <span class="math">b</span> is a proof
of <span class="math">Y</span>.</p></li><li><p><span class="math">\neg X</span> is still defined as <span class="math">X \to \bot</span>.</p></li><li><p><span class="math">\bot</span> has no proof.</p></li></ul></div></p><p>As an example, suppose that I wanted to prove <span class="math">(A \land \neg A) \to \bot</span>, otherwise known as the law of
non-contradiction. Then, I would want to construct a function from <span class="math">A \land \neg A</span> to <span class="math">\bot</span>.</p><p><span class="math">A \land \neg A</span> is interpreted as a pair of proofs for <span class="math">A</span> and <span class="math">\neg A</span>, and <span class="math">\neg A</span> is interpreted
as a function <span class="math">A \to \bot</span>.</p><p>So, the function <span class="math">f((a, n)) = n(a)</span> is a witness to <span class="math">(A \land \neg A) \to \bot</span> under the BHK interpretation.</p><h5>3.1.8<tt>&nbsp;</tt><a name="(part._.Intuitionistic_propositional_logic__proof_system)"></a>Intuitionistic propositional logic: proof system</h5><p>In the last lecture, we wrote down a set of rules for classical propositional logic. The set of Gentzen-style
rules for IPL are exactly the same, except without the rule <span class="math">\mathsf{DNE}</span>.</p><p>Why is this the case? Note that in the BHK interpretation, there is not a clear way to construct a witness to
<span class="math">\neg \neg A \to A</span>. The only thing we have is a function, the only way we can eliminate a function is to
apply it to an argument, and we have no means to conjure an argument to our function out of thin air.</p><p>Tying this proof system to the BHK interpretation is the work of <span style="font-style: italic">elaboration</span>, a later topic in this
course.</p><h4>3.2<tt>&nbsp;</tt><a name="(part._.Designing_tactics)"></a>Designing tactics</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}
\newcommand{\fst}[1]{\mathsf{fst\ } #1}
\newcommand{\snd}[1]{\mathsf{snd\ } #1}</div></p><h5>3.2.1<tt>&nbsp;</tt><a name="(part._.Tactics)"></a>Tactics</h5><p>We now have a proof system for IPL. We would like to write code that actually verifies our proofs.
To try and create this correspondence, we define a kind of reusable checker, known as a tactic.</p><p><span style="font-weight: bold">Definition:</span> A <span style="font-style: italic">context</span>, usually denoted by <span class="math">\Gamma</span>, is an association of names of witnesses
to the propositions they prove. So, the empty context represents no assumptions, and the context
<span class="math">x : A, y : B</span> represents a witness named <span class="math">x</span> that proves <span class="math">A</span>, and a witness named <span class="math">y</span> that proves
<span class="math">B</span>.</p><p><span style="font-style: italic">Note:</span> This is very similar to the notion of an environment from 311.</p><p><span style="font-weight: bold">Definition:</span> A <span style="font-style: italic">check tactic</span>, or <span class="stt">ChkTactic</span> in code, is a function <span class="stt">Context Prop -&gt; Void</span>
that, given a context and a proposition, does nothing if it can prove the proposition under the context, and
errors if it cannot.</p><p><span style="font-weight: bold">Definition:</span> An <span style="font-style: italic">infer tactic</span>, or <span class="stt">SynTactic</span> in code, is a function <span class="stt">Context -&gt; Prop</span>
that, given a context, returns the proposition that it proves.</p><p>We define <span style="font-style: italic">tactic combinators</span>, functions that take and return tactics, to represent each rule. This
leads us to the <span style="font-weight: bold">design recipe for tactics:</span></p><p><div class="SIntrapara">Given an inference rule:
</div><div class="SIntrapara"><ol><li><p><span style="font-weight: bold">Determine your output.</span> As a general rule of thumb, introduction rules turn into check tactics,
and elimination rules turn into infer tactics.</p></li><li><p><span style="font-weight: bold">Solve your unknowns.</span> Determine what information above the line needs to be present to check
or infer the proposition that you need.</p></li><li><p><span style="font-weight: bold">Signature.</span> All the things above the line turn into inputs, with their type depending
on step 2, and your output turns into your return type.</p></li><li><p><span style="font-weight: bold">Design your function.</span> This means writing tests, determining how it fits in with other tactics.</p></li><li><p><span style="font-weight: bold">Test.</span></p></li></ol></div></p><p>Most of the first few steps will be given to you for assignments 1 and 2, primarily because we do not yet have
the machinery to make well-informed decisions on what should be a check tactic versus an infer tactic.</p><h5>3.2.2<tt>&nbsp;</tt><a name="(part._.Propositions_in_.Racket)"></a>Propositions in Racket</h5><p><div class="SIntrapara">As we move from paper to code, we have to turn our grammars into data definitions. So:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Proposition is one of:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (prop-atomic Symbol)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (prop-&#8594; Proposition Proposition)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (prop-&#8743; Proposition Proposition)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (prop-&#8744; Proposition Proposition)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (prop-&#8869;)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">name</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">prop-&#8594;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktSym">consequent</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">prop-&#8743;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">left</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">prop-&#8744;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">left</span><span class="hspace">&nbsp;</span><span class="RktSym">right</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">prop-&#8869;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">where we omit <span class="math">\neg</span> because it is superfluous in the presence of <span class="math">\bot</span>.</div></p><p><div class="SIntrapara">It is tedious to write out these, and they do not pretty-print well. So, we define two helper functions
that take S-expressions to propositions and back:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">parse : Sexp -&gt; Prop</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Parses an infix S-expression into a proposition.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">s</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">&#8594;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">consequent</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8594;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="hspace">&nbsp;</span><span class="RktSym">assumption</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="hspace">&nbsp;</span><span class="RktSym">consequent</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktVal">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">r</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8743;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktVal">&#8744;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">r</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8744;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">&#172;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktSym">v</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8594;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="hspace">&nbsp;</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">&#8869;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">?</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._symbol~3f%29%29" class="RktValLink" data-pltdoc="x">symbol?</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">pp : Prop -&gt; Sexp</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Pretty-prints a proposition.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">pp</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktSym">name</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">name</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">prop-&#8594;</span><span class="hspace">&nbsp;</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktSym">consequent</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">pp</span><span class="hspace">&nbsp;</span><span class="RktSym">assumption</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">&#8594;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">pp</span><span class="hspace">&nbsp;</span><span class="RktSym">consequent</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">prop-&#8743;</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">pp</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">pp</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">prop-&#8744;</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">pp</span><span class="hspace">&nbsp;</span><span class="RktSym">l</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">&#8744;</span><span class="hspace">&nbsp;</span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">pp</span><span class="hspace">&nbsp;</span><span class="RktSym">r</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">&#8869;</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><h5>3.2.3<tt>&nbsp;</tt><a name="(part._.Tactics_in_.Racket)"></a>Tactics in Racket</h5><p>First, we provide our data definition and helper function for a context.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Context is a [Listof [Pairof Symbol Prop]]</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">extend-context : Context Symbol Prop -&gt; Context</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Adds a witness of the given proposition to the context.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">name</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">name</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktVal">. </span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Note that this is effectively the same as the data-structural representation of an environment from 311: we
define it as an association list instead of a tagged list, however.</p><p><div class="SIntrapara">We then define tactics not solely as their underlying function, but as a structure that can be called as
a function:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A ChkTactic is a (chk-tactic Symbol [Context Prop -&gt; Void])</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A SynTactic is a (syn-tactic Symbol [Context -&gt; Prop])</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">chk-tactic</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">name</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:transparent</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:property</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._prop~3aprocedure%29%29" class="RktValLink" data-pltdoc="x">prop:procedure</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct-field-index%29%29" class="RktStxLink" data-pltdoc="x">struct-field-index</a></span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">syn-tactic</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">name</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:transparent</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:property</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._prop~3aprocedure%29%29" class="RktValLink" data-pltdoc="x">prop:procedure</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct-field-index%29%29" class="RktStxLink" data-pltdoc="x">struct-field-index</a></span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">run-chk : Prop ChkTactic -&gt; Void</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Runs the given check tactic on the input proposition.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-chk</span><span class="hspace">&nbsp;</span><span class="RktSym">goal</span><span class="hspace">&nbsp;</span><span class="RktSym">tactic</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tactic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktSym">goal</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">run-syn : SynTactic -&gt; Prop</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Runs the given synthesis tactic, producing the proposition it witnesses.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-syn</span><span class="hspace">&nbsp;</span><span class="RktSym">tactic</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tactic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>We define these using <span class="RktSym"><a href="https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._prop~3aprocedure%29%29" class="RktValLink" data-pltdoc="x">prop:procedure</a></span> for one reason: it is very advantageous to have error messages
reference both the name of the input tactic (which is what the <span class="stt">name</span> field is for), and it makes our
contracts significantly easier to write while also referencing <span class="RktSym">chk-tactic?</span> rather than a function
contract.</p><p>The <span class="RktSym">run-chk</span> and <span class="RktSym">run-syn</span> functions are merely wrappers that run the tactics on empty contexts.
These are usually used for top-level proofs, as we will see later.</p><h5>3.2.4<tt>&nbsp;</tt><a name="(part._.Our_first_example__variable_references)"></a>Our first example: variable references</h5><p>We first design our very first rule, which we need to be able to have a base case. All of our tactic
<span style="font-style: italic">combinators</span> take other tactics as inputs, but we need some tactic that does not depend on other tactics.</p><p>We have our <span class="stt">Context</span>, which maps names of witnesses to their propositions. However, we need a way to turn
one of those witnesses into a tactic that can be provided to combinators.
So, we start by noting that we have no tactics as inputs, and that we will be returning a <span class="stt">SynTactic</span>,
as (by the next section) we can turn a <span class="stt">SynTactic</span> into a <span class="stt">ChkTactic</span> easily, but not the other way
around.</p><p><div class="SIntrapara">So, the signature of our function is <span class="stt">assumption : Symbol -&gt; SynTactic</span>. We now write our purpose statement
and template:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">assumption : Symbol -&gt; SynTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *variable rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given a witness x of P in the context,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">returns a tactic corresponding to x.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._symbol~3f%29%29" class="RktValLink" data-pltdoc="x">symbol?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">syn-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assumption</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Then, we write some tests. Given a context where <span class="math">x : B</span>, we want to return the proposition <span class="math">B</span>. So,
we write tests that codify that:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8594;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8594;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-error</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">We then use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/dicts.html#%28def._%28%28lib._racket%2Fdict..rkt%29._dict-ref%29%29" class="RktValLink" data-pltdoc="x">dict-ref</a></span> to fill in our function body, which does what it says on the tin:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">assumption : Symbol -&gt; SynTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *variable rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given a witness x of P in the context,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">imbues x with being a witness of P.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._symbol~3f%29%29" class="RktValLink" data-pltdoc="x">symbol?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">syn-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assumption</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/dicts.html#%28def._%28%28lib._racket%2Fdict..rkt%29._dict-ref%29%29" class="RktValLink" data-pltdoc="x">dict-ref</a></span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">and all our tests pass.</div></p><h5>3.2.5<tt>&nbsp;</tt><a name="(part._.Examples__conversion_and_annotation)"></a>Examples: conversion and annotation</h5><p>Let&rsquo;s work on some of the most basic rules we need in a system like this. Given a check tactic,
to make our types line up with all of our combinators, we need to be able to create an infer tactic, and vice
versa.</p><p>We use the <span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span> form to state our signatures and have them checked at runtime, as it
results in errors that yell about what tactic you used and whether or not it was a check/infer tactic, rather
than incomprehensible errors about procedure arity.</p><p>So, we will implement a tactic combinator <span class="stt">chk : SynTactic -&gt; ChkTactic</span>, which takes an infer tactic
and produces a check tactic with the same behavior. So, given that we have a witness <span style="font-style: italic">of</span> <span class="math">P</span>, we can
create a witness that <span style="font-style: italic">checks as</span> <span class="math">P</span>.</p><p>Steps 1, 2, and 3 of our design recipe are trivial.</p><p><div class="SIntrapara">As for step 4, we begin by writing our our purpose statement, contract, and template:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">chk : SynTactic -&gt; ChkTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *conversion rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given that t is a witness of the proposition P,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">then t is also able to be checked as a witness of P.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktSym">tac</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic?</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">chk-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">chk</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">goal</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">We now need to write some tests. The only base tactic we have is <span class="stt">assumption</span>, so we simply turn
it into a <span class="stt">ChkTactic</span> using our combinator and see what happens:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8594;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-success</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-success</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8594;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-error</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">z</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-error</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>So, we begin our game of type tetris to fill in the definition. We know that <span class="stt">&#915;</span> is a <span class="stt">Context</span>,
that <span class="stt">goal</span> is a <span class="stt">Prop</span>, and that <span class="stt">tac</span> is a <span class="stt">SynTactic</span> that we can apply to a <span class="stt">Context</span>
to get a <span class="stt">Prop</span>.</p><p>Therefore, for our tactic, we want to throw an error if we can&rsquo;t check as the input. But we know what the
input needs to be: the result of <span class="stt">tac</span>.</p><p><div class="SIntrapara">So:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">chk : SynTactic -&gt; ChkTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *conversion rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given that t is a witness of the proposition P,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">then t is also able to be checked as a witness of P.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktSym">tac</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic?</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">chk-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">chk</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">goal</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tac</span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assert-prop-equal!</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="hspace">&nbsp;</span><span class="RktSym">goal</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">where we use the wishlist method to get <span class="stt">assert-prop-equal! : Prop Prop -&gt; Void</span>, which does what it
says on the tin. You will implement this function in assignment 1.</div></p><p>To go the other direction and make a function <span class="stt">imbue</span> that takes a <span class="stt">ChkTactic</span> and returns a
<span class="stt">SynTactic</span>, note that we have an unknown: we aren&rsquo;t able to use a <span class="stt">ChkTactic</span> without a proposition.
So, we add a proposition as an argument, and our signature is <span class="stt">imbue : ChkTactic Prop -&gt; SynTactic</span>.</p><p><div class="SIntrapara">So, purpose statement, contract, template:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">imbue : ChkTactic Prop -&gt; SynTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *annotation rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given that t can check as the proposition P,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">allows t to be imbued with being a witness of P.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">imbue</span><span class="hspace">&nbsp;</span><span class="RktSym">tac</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk-tactic?</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/data-structure-contracts.html#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._any%2Fc%29%29" class="RktValLink" data-pltdoc="x">any/c</a></span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">syn-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">imbue</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">We write <span class="RktSym"><a href="https://docs.racket-lang.org/reference/data-structure-contracts.html#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._any%2Fc%29%29" class="RktValLink" data-pltdoc="x">any/c</a></span> for brevity&rsquo;s sake.</div></p><p><span class="stt">tac</span> is a <span class="stt">ChkTactic</span>, which performs a side effect to determine if it checks as the input proposition.
So, we have a <span class="stt">Context</span> <span class="stt">&#915;</span>, and we have a <span class="stt">Prop</span> <span class="stt">prop</span>. Consequently, <span class="RktPn">(</span><span class="RktSym">tac</span><span class="stt"> </span><span class="RktSym">&#915;</span><span class="stt"> </span><span class="RktSym">prop</span><span class="RktPn">)</span>
will run <span class="stt">tac</span> on the context and proposition we have as known variables, and then error if there&rsquo;s an issue.</p><p>Finally, since <span class="RktPn">(</span><span class="RktSym">tac</span><span class="stt"> </span><span class="RktSym">&#915;</span><span class="stt"> </span><span class="RktSym">prop</span><span class="RktPn">)</span> returns <span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span>, and we&rsquo;re creating a <span class="stt">SynTactic</span>, we still need
to return a proposition that our new tactic is a witness of. This is merely <span class="stt">prop</span>.</p><p><div class="SIntrapara">So, our final code is:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">imbue : ChkTactic Prop -&gt; SynTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *annotation rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given that t can check as the proposition P,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">allows t to be imbued with being a witness of P.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">imbue</span><span class="hspace">&nbsp;</span><span class="RktSym">tac</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk-tactic?</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/data-structure-contracts.html#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._any%2Fc%29%29" class="RktValLink" data-pltdoc="x">any/c</a></span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">syn-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">imbue</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tac</span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>We do not add tests to <span class="stt">imbue</span> yet, because we have no good <span class="stt">ChkTactic</span>s to test with.</p><h5>3.2.6<tt>&nbsp;</tt><a name="(part._.Check_versus_infer_and_solving_unknowns)"></a>Check versus infer and solving unknowns</h5><p>Let&rsquo;s think a bit harder about why we have these different tactics. In particular, let&rsquo;s look at the rule
for implication elimination:
<div class="math">\ir{(\to_{\mathrm{elim}})}{A \to B ~~~ A}{B}</div></p><p>So, given that <span class="math">A \to B</span> and <span class="math">A</span>, we can prove <span class="math">B</span>. Under our system, it is not at all straightforward
to know how to actually do this. How do we know what <span class="math">A</span> and <span class="math">B</span> are?</p><p>This is the purpose of our check/infer system, known in the literature as <span style="font-weight: bold">bidirectional typing</span>.
Our <span style="font-style: italic">check</span> rules correspond to what would be known in type theory as "type checking", and our
<span style="font-style: italic">infer</span> rules correspond to "type inference" or "type synthesis".</p><p>The question then turns to how to do our design recipe steps 1-2, of figuring out which things above the line
and below the line are check/infer. Let&rsquo;s step through why <span class="stt">modus-ponens : SynTactic ChkTactic -&gt; SynTactic</span>
works.</p><p>First, we infer the proposition corresponding to the implication. Our input <span class="stt">SynTactic</span> gives us the
proposition <span class="math">A \to B</span>. So, now that we know <span class="math">A \to B</span>, we know what <span class="math">A</span> is and <span class="math">B</span> is. Consequently,
we are free to check our tactic witnessing the assumption as <span class="math">A</span>, so that can be a <span class="stt">ChkTactic</span>.</p><p>Finally, we also know <span class="math">B</span>, which is our consequent, so we are free to return it, thereby giving us a
<span class="stt">SynTactic</span>.</p><p>So how do we determine exactly what combination to use? We design our systems around the criterion of
<span style="font-style: italic">mode-correctness</span>:</p><p><div class="SIntrapara"><span style="font-weight: bold">Definition:</span> A bidirectional judgment is <span style="font-style: italic">mode-correct</span> if:
</div><div class="SIntrapara"><ul><li><p>the premises are mode-correct: for each premise, the input meta-variable is known.</p></li><li><p>the conclusion is mode-correct: if we have all the premises, the output of the conclusion is known.</p></li></ul></div></p><p>So, for example, the signature <span class="stt">modus-ponens : ChkTactic ChkTactic -&gt; ChkTactic</span> is <span style="font-style: italic">not</span> mode-correct.
We know <span class="math">B</span> from the goal of the conclusion, but we have no way of figuring out what <span class="math">A</span> is to be able
to construct the proposition <span class="math">A \to B</span>.</p><p><div class="SIntrapara">The mode-correct ways to construct <span class="stt">modus-ponens</span> are:
</div><div class="SIntrapara"><ul><li><p><span class="stt">SynTactic SynTactic -&gt; SynTactic</span></p></li><li><p><span class="stt">SynTactic ChkTactic -&gt; SynTactic</span></p></li><li><p><span class="stt">SynTactic ChkTactic -&gt; ChkTactic</span></p></li><li><p><span class="stt">ChkTactic SynTactic -&gt; ChkTactic</span></p></li></ul></div><div class="SIntrapara">where the fourth one is a bit more complex as to why: we need to synthesize the proposition of the consequent
before we can construct the assumption.</div></p><p>Note that <span style="font-style: italic">if your system is not mode-correct, it cannot be written in code.</span></p><p>The decision to go with introduction rules as check tactics and elimination rules as infer tactics is common
practice, though entirely arbitrary. Any mode-correct rule will technically work.</p><p>Note, however, that because <span class="stt">imbue</span> returns a <span class="stt">SynTactic</span>, the different rules change the
<span style="font-style: italic">annotation characteristic</span> of our language &#8212;<wbr></wbr> when we eventually make the jump from propositions
to types and then to concrete syntax, where we put our <span class="stt">SynTactic</span>s vs <span class="stt">ChkTactic</span>s will change where
we have to annotate our terms.</p><p><div class="SIntrapara">For this reason, we have two somewhat arbitrary rules we use to narrow down which mode-correct rules work:
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">Avoid asserting equality.</span> If you need to use <span class="stt">assert-prop-equal!</span> anywhere, you can probably
get away with a <span class="stt">ChkTactic</span> rather than a <span class="stt">SynTactic</span>. Same goes for calling <span class="stt">chk</span> anywhere
<span style="font-style: italic">within</span> your tactic.</p></li><li><p><span style="font-weight: bold">Intro rules are check, elimination rules are infer.</span> This is a pretty good baseline to get a good
annotation characteristic. Whenever you see an eliminator, you can mentally note that you probably need an
annotation.</p></li></ul></div></p><h4>3.3<tt>&nbsp;</tt><a name="(part._.Elaboration)"></a>Elaboration</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}
\newcommand{\fst}[1]{\mathsf{fst\ } #1}
\newcommand{\snd}[1]{\mathsf{snd\ } #1}</div></p><h5>3.3.1<tt>&nbsp;</tt><a name="(part._.What_)"></a>What?</h5><p>In A1, we have a set of tactics that correspond to each individual rule of our IPL proof system. However, we are
still missing the crucial piece that ties our BHK interpretation to each rule. This piece is known as
<span style="font-style: italic">elaboration</span>, and will be the start of our shift from propositions to types.
The goal of elaboration is for our tactics to produce not just a yes/no answer as to whether our proof is correct,
but a piece of syntax that, under the BHK interpretation, is an object you can hand me.</p><p>First, we are computer scientists, so we will be representing "functions" in the BHK interpretation using lambdas.
In other words, our old example of <span class="math">\neg (A \land \neg A)</span> being represented as <span class="math">f((a, n)) = n(a)</span> is now
represented by <span class="math">\lambda p. (\snd{p}) (\fst{p})</span>.</p><p>For the time being, we restrict our focus to the implicational fragment of our proof system. In A2, we will be
adding back our connectives.</p><p><div class="SIntrapara"><span style="font-weight: bold">Definition:</span> A <span class="stt">Syntax</span> is defined as:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td align="right" valign="baseline"><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">Syntax</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">syntax-local</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28lib._racket%2Fmath..rkt%29._natural~3f%29%29" class="RktValLink" data-pltdoc="x">natural?</a></span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">syntax-lam</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._symbol~3f%29%29" class="RktValLink" data-pltdoc="x">symbol?</a></span><span class="hspace">&nbsp;</span><span class="RktVar">Syntax</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">syntax-app</span><span class="hspace">&nbsp;</span><span class="RktVar">Syntax</span><span class="hspace">&nbsp;</span><span class="RktVar">Syntax</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">and represented with the Racket definition:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Syntax is one of:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A DeBruijn *level*:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (syntax-local NaturalNumber)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A lambda:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (syntax-lam Symbol Syntax)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">An application:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (syntax-app Syntax Syntax)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">syntax-local</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">syntax-lam</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">syntax-app</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">These are also referred to as <span style="font-style: italic">core terms</span>.</div></p><h5>3.3.2<tt>&nbsp;</tt><a name="(part._.De.Bruijn_levels)"></a>DeBruijn levels</h5><p>Note that I mention DeBruijn levels here. Traditionally, we define a DeBruijn index, as in 311, as a way of
"pointing out" to our lambda. So, for example, the term
<div class="math">\lambda x. \lambda y. x \mathrm{\ \ becomes\ \ } \lambda \lambda\ 1</div>
noting that we start indexing from zero, or
<div class="math">\lambda z. (\lambda y. y\ (\lambda x. x)) (\lambda x. z\ x)
\mathrm{\ \ becomes \ \ }
\lambda\ (\lambda\ 0\ (\lambda\ 0)) (\lambda\ 1\ 0)</div></p><p>DeBruijn levels are the dual to these: instead of counting inside out, we count outside in. So:
<div class="math">\lambda x. \lambda y. x \mathrm{\ \ becomes\ \ } \lambda \lambda\ 0</div>
<div class="math">\lambda z. (\lambda y. y\ (\lambda x. x)) (\lambda x. z\ x)
\mathrm{\ \ becomes \ \ }
\lambda\ (\lambda\ 1\ (\lambda\ 2)) (\lambda\ 0\ 1)</div></p><p>The motivation for this is that we can now not only unambiguously refer to variables as with DeBruijn indices,
but we do not need to keep track of the environment size at all: we can simply use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list-ref%29%29" class="RktValLink" data-pltdoc="x">list-ref</a></span> as our
environment application.</p><h5>3.3.3<tt>&nbsp;</tt><a name="(part._.Elaborating_tactics)"></a>Elaborating tactics</h5><p>Our last iteration of tactics has no clear way to return anything beyond a yes/no result. So, we need to update
our definition of a tactic.</p><p><span style="font-weight: bold">Definition:</span> A <span style="font-style: italic">check tactic</span> is now a function <span class="stt">Context Prop -&gt; Syntax</span> that, given a context
and a proposition, returns the BHK interpretation of the proof it represents if it can prove the proposition
under the context, and errors if it cannot.</p><p><span style="font-weight: bold">Definition:</span> A <span style="font-style: italic">infer tactic</span> is now a function <span class="stt">Context -&gt; [PairOf Prop Syntax]</span> that, given
a context, returns both the proposition that it proves and the BHK interpretation of the proof of that
proposition.</p><p>So, we now change our data definitions routinely. <span class="stt">run-chk</span> is now <span class="stt">Prop ChkTactic -&gt; Syntax</span>,
<span class="stt">run-syn</span> is now <span class="stt">SynTactic -&gt; [PairOf Prop Syntax]</span>, et cetera.</p><p><div class="SIntrapara">We define a helper to DeBruijnize the variables in our context:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">context-index-of : Context Symbol -&gt; NaturalNumber</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Returns the index of the symbol in the context.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">context-index-of</span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"not found"</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">rst</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._cond%29%29" class="RktStxLink" data-pltdoc="x">cond</a></span><span class="hspace">&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Equality.html#%28def._%28%28quote._~23~25kernel%29._eq~3f%29%29" class="RktValLink" data-pltdoc="x">eq?</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/if.html#%28form._%28%28lib._racket%2Fprivate%2Fletstx-scheme..rkt%29._else%29%29" class="RktStxLink" data-pltdoc="x">else</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._add1%29%29" class="RktValLink" data-pltdoc="x">add1</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">context-index-of</span><span class="hspace">&nbsp;</span><span class="RktSym">rst</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-error</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">context-index-of</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">context-index-of</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">context-index-of</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">which simply does structural recursion on the context. This returns a DeBruijn <span style="font-style: italic">index</span> &#8212;<wbr></wbr> the shift
to levels will make more sense when we switch to higher-order abstract syntax for our tactics.</div></p><p>So, our old tactics need some adjustment. We start with <span class="stt">assumption</span>, which returns a <span class="stt">SynTactic</span>,
which needs to return both a proposition and a core term.</p><p><div class="SIntrapara">Our core term will be a <span class="stt">syntax-local</span>, which stores the DeBruijn level, which is equal to the length of the
context minus the DeBruijn index minus one. So:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">assumption : Symbol -&gt; SynTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *variable rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given a witness x : P in the context,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">returns a tactic corresponding to x.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._symbol~3f%29%29" class="RktValLink" data-pltdoc="x">symbol?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">syn-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assumption</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/dicts.html#%28def._%28%28lib._racket%2Fdict..rkt%29._dict-ref%29%29" class="RktValLink" data-pltdoc="x">dict-ref</a></span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syntax-local</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._-%29%29" class="RktValLink" data-pltdoc="x"><span class="nobreak">-</span></a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">context-index-of</span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syntax-local</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-error</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-syn</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Note that this assumes that your <span class="stt">introduce</span> from A1 uses <span class="stt">extend-context</span> in the normal way. (If you
haven&rsquo;t looked at A1 yet, do that!)</p><p><div class="SIntrapara"><span class="stt">chk</span> is a relatively routine change. We use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match-define%29%29" class="RktStxLink" data-pltdoc="x">match-define</a></span> to extract the proposition and
core term from the input <span class="stt">SynTactic</span>, then return the term it produces, as adding <span class="stt">chk</span>s should
not impact the BHK term:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">chk : SynTactic -&gt; ChkTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *conversion rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given that t is a witness of P,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">then t is able to be checked as a witness of P.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktSym">tac</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic?</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">chk-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">chk</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">goal</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match-define%29%29" class="RktStxLink" data-pltdoc="x">match-define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="hspace">&nbsp;</span><span class="RktSym">tm</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tac</span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assert-prop-equal!</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="hspace">&nbsp;</span><span class="RktSym">goal</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">tm</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8594;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syntax-local</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8594;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syntax-local</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-error</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">The same principle applies for <span class="stt">imbue</span>, in which we get the term generated by the input <span class="stt">ChkTactic</span>
and spit it back out:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">imbue : ChkTactic Prop -&gt; SynTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *annotation rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given that t can check as the proposition P,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">gives us a new tactic that is a witness of P.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">imbue</span><span class="hspace">&nbsp;</span><span class="RktSym">tac</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk-tactic?</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/data-structure-contracts.html#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._any%2Fc%29%29" class="RktValLink" data-pltdoc="x">any/c</a></span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">syn-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">imbue</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">tm</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tac</span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="hspace">&nbsp;</span><span class="RktSym">tm</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">imbue</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syntax-local</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-error</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">imbue</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Turning the rest of your A1 tactics into elaborating ones is part of the subject of A2.</p><h4>3.4<tt>&nbsp;</tt><a name="(part._.The_simply-typed_lambda_calculus)"></a>The simply-typed lambda calculus</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}
\newcommand{\fst}[1]{\mathsf{fst\ } #1}
\newcommand{\snd}[1]{\mathsf{snd\ } #1}</div></p><h5>3.4.1<tt>&nbsp;</tt><a name="(part._.The_.Curry-.Howard_correspondence)"></a>The Curry-Howard correspondence</h5><p>Surprise! We&rsquo;re doing type theory in the type theory class. Big reveal.</p><p><div class="SIntrapara">In particular, every instance of the word "proposition" in this course can be replaced with "type".
The following propositions can be interpreted as the following types in a conventional simply typed
lambda calculus:
</div><div class="SIntrapara"><ul><li><p>Function types correspond to implications.</p></li><li><p>Product types/pair types correspond to logical and.</p></li><li><p>Sum types correspond to logical or.</p></li><li><p>The empty type corresponds to <span class="math">\bot</span>.</p></li></ul></div><div class="SIntrapara">In addition, our natural deduction proof system for IPL corresponds directly to the type system
for the simply typed lambda calculus.</div></p><p>Given the way that we represent BHK terms after elaboration, this should serve as no surprise.</p><p>In addition, this gives the somewhat surprising correspondence that an inhabited type corresponds to
an intuitionistic tautology.</p><p>However, in type theory, we traditionally have a term associated with a type. We define our
<span style="font-style: italic">concrete syntax</span> to be this kind of term, with the traditional lambda calculus grammar:
<div class="math">e ::= x \mid \lambda x. e \mid e\ e \mid e : \tau</div>
and we give grammar to our types as well:
<div class="math">\tau ::= A \mid \tau \to \tau</div></p><p><div class="SIntrapara">We also give Racket data definitions for these, calling our terms before elaboration <span class="stt">ConcreteSyntax</span>
and after elaboration merely <span class="stt">Syntax</span>:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A ConcreteSyntax is one of:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (cs-var Symbol)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (cs-lam Symbol ConcreteSyntax)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (cs-app ConcreteSyntax ConcreteSyntax)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (cs-ann ConcreteSyntax Type)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">cs-var</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">name</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">cs-lam</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">cs-app</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">cs-ann</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tm</span><span class="hspace">&nbsp;</span><span class="RktSym">tp</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">noting that we have changed our original <span class="stt">Prop</span> data definition to <span class="stt">Type</span>. Note that also we have
the <span class="stt">cs-ann</span> node in our concrete syntax, but not in our core terms!</div></p><h5>3.4.2<tt>&nbsp;</tt><a name="(part._.Type_theory_notation)"></a>Type theory notation</h5><p>Before we move on to writing a type checker for STLC, we should actually state our type rules.</p><p>First, the most glaringly strange thing in our current IPL proof system is the notion of a hypothetical
derivation in our intro rule:
<div class="math">\ir{(\to_{\mathrm{intro}})}
   {\begin{matrix}
      \ir{}{}{A} \\
      \vdots \\
      B
    \end{matrix}}
   {A \to B}</div></p><p>The notion of hypothetical dervation is useful, but currently exists at a meta-theoretic level.
We now begin to label our antecedents with names, put them in our context, and then use the symbol <span class="math">\vdash</span>
to mean "proves".</p><p>In addition, we annotate each bit of our concrete syntax (corresponding to a non-elaborated BHK interpretation)
with its type.</p><p>As an immediate example, our implication introduction rule becomes:
<div class="math">\ir{(\to_\mathrm{intro})}
   {\Gamma, x : A \vdash y : B}
   {\Gamma \vdash \lambda x. y : A \to B}</div></p><p>Let&rsquo;s break this down. The line <span class="math">\Gamma, x : A \vdash y : B</span> reads "under a context <span class="math">\Gamma</span> where <span class="math">x</span> has
type <span class="math">A</span>, we can prove <span class="math">y</span> has type <span class="math">B</span>". Note the subtle distinction between <span class="math">:</span> on the left hand side
of <span class="math">\vdash</span> compared to the right.</p><p>We now need to rephrase our other rules in a similar fashion. Implication elimination is straightforward:
<div class="math">\ir{(\to_\mathrm{elim})}
   {\Gamma \vdash f : A \to B ~~~ \Gamma \vdash a : A}
   {\Gamma \vdash f\ a : B}</div></p><p>To finish up the proof system for the implicational fragment of IPL, we need to add one more rule with regards
to contexts that made no sense prior. In particular, we need a way to extract things from our context:
<div class="math">\ir{(\mathrm{Var})}
   {x : A \in \Gamma}
   {\Gamma \vdash x : A}</div>
noting that <span class="math">\in</span> is effectively set-theoretic inclusion. Since contexts are finite, this is fine.</p><p>All of our other rules are more or less trivial to rephrase like this.</p><p>As an example, we are now free to actually write a proof tree to show that
<span class="math">\vdash \lambda x. \lambda y. x : A \to (B \to A)</span>:
<div class="math">\ir{(\to_\mathrm{intro})}
   {\ir{(\to_\mathrm{intro})}
       {\ir{(\mathrm{Var})}
           {x : A \in \Gamma, x : A, y : B}
           {\Gamma, x : A, y : B \vdash x : A}}
       {\Gamma, x : A \vdash \lambda y. x : B \to A}}
   {\Gamma \vdash \lambda x. \lambda y. x : A \to (B \to A)}</div></p><p>We then also wrote a proof tree for <span class="math">\vdash \lambda a. \lambda f. f\ a : A \to ((A \to B) \to B)</span> in class.
(If you&rsquo;re reading this alone, do it yourself!)</p><h5>3.4.3<tt>&nbsp;</tt><a name="(part._.Bidirectional_typing)"></a>Bidirectional typing</h5><p>We&rsquo;ve already been doing this for quite some time, but the time has come to formalize our tactics in good old
fashioned math notation.</p><p>Our <span class="math">\Gamma \vdash x : A</span> notation is relatively good, but does not give us a straightforward path to
implementation. Our check tactics, which correspond to the sequent <span class="math">\Gamma \vdash x : A</span> being valid,
are written as <span class="math">\Gamma \vdash x \Leftarrow A</span>. Our infer tactics, which correspond to the sequent giving
us what it proves, is written as <span class="math">\Gamma \vdash x \Rightarrow A</span>.</p><p>If we simply adapt our existing signatures to the three rules for the implicational fragment of STLC above,
we get the following rules:
<div class="math">\ir{(\to_\mathrm{intro})}
   {\Gamma, x : A \vdash y \Leftarrow B}
   {\Gamma \vdash \lambda x. y \Leftarrow A \to B}</div>
<div class="math">\ir{(\to_\mathrm{elim})}
   {\Gamma \vdash f \Rightarrow A \to B ~~~ \Gamma \vdash a \Leftarrow A}
   {\Gamma \vdash f\ a \Rightarrow B}</div>
<div class="math">\ir{(\mathrm{Var})}
   {x : A \in \Gamma}
   {\Gamma \vdash x \Rightarrow A}</div></p><p>To sanity check our work, we define a criterion to know when we&rsquo;re done writing our bidirectional rules:</p><p><span style="font-weight: bold">Definition:</span> A bidirectional type system is <span style="font-style: italic">complete</span> if whenever <span class="math">\Gamma \vdash e : T</span>,
then <span class="math">\Gamma \vdash e&rsquo; \Leftarrow T</span> and <span class="math">\Gamma \vdash e&rsquo; \Rightarrow T</span>, where <span class="math">e&rsquo;</span> is a version of <span class="math">e</span>
with any amount of added type annotations.</p><p>This system doesn&rsquo;t seem complete, and it&rsquo;s not. If we try to construct the proof tree for
<span class="math">\vdash \lambda a. \lambda f. f\ a : A \to ((A \to B) \to B)</span>, we can&rsquo;t, because we have no way to turn
inference into checking and vice versa. In our tactic system, we wrote <span class="stt">chk</span> and <span class="stt">imbue</span> for this purpose,
so let&rsquo;s turn them into rules.</p><p><span class="stt">chk</span> is relatively easy, and is called the conversion rule:
<div class="math">\ir{(\mathrm{Conv})}
   {\Gamma \vdash x \Rightarrow A&rsquo; ~~~ A \equiv A&rsquo;}
   {\Gamma \vdash x \Leftarrow A}</div>
where <span class="math">A \equiv A&rsquo;</span> means <span class="stt">prop=?</span> for now. For brevity in examples, we may use this version of the rule:
<div class="math">\ir{(\mathrm{Conv})}
   {\Gamma \vdash x \Rightarrow A}
   {\Gamma \vdash x \Leftarrow A}</div>
which means the same thing, except the definitional equality is implied by <span class="math">A</span> being the same thing on both
the top and the bottom.</p><p>Going the other way with <span class="stt">imbue</span> is more complicated, and what our <span class="stt">cs-ann</span> notation is for. This is yet
another override of what colon means.
<div class="math">\ir{(\mathrm{Ann})}
   {\Gamma \vdash x \Leftarrow A}
   {\Gamma \vdash (x : A) \Rightarrow A}</div></p><p>We now write the proof tree for
<span class="math">\vdash \lambda a. \lambda f. f\ a \Leftarrow A \to ((A \to B) \to B)</span>. (Again, do it yourself!)</p><h5>3.4.4<tt>&nbsp;</tt><a name="(part._.Checking_our_concrete_syntax)"></a>Checking our concrete syntax</h5><p><div class="SIntrapara">Now that we have a notion of our concrete terms and how to check them, it&rsquo;s time to compile our terms to tactics.
We first start by renaming our tactics:
</div><div class="SIntrapara"><ul><li><p><span class="stt">chk</span> stays the same.</p></li><li><p><span class="stt">imbue</span> becomes <span class="stt">ann</span>.</p></li><li><p><span class="stt">introduce</span> stays the same.</p></li><li><p><span class="stt">modus-ponens</span> becomes <span class="stt">app</span>.</p></li><li><p><span class="stt">assumption</span> becomes <span class="stt">var</span>.</p></li></ul></div></p><p>We now want to <span style="font-style: italic">make</span> a type checker (or synthesizer) given a term. We do this with two functions:
<span class="stt">type-check : ConcreteSyntax -&gt; ChkTactic</span>, and <span class="stt">type-infer : ConcreteSyntax -&gt; SynTactic</span>, each of which
produces a tactic corresponding to the syntax we have.</p><p>In the context of <span class="stt">type-check</span>, you can think of this kind of like a curried verifier for a given sequent:
to show that <span class="math">\Gamma \vdash e \Leftarrow T</span>, we give <span class="stt">type-check</span> <span class="math">e</span>, and it gives us a tactic
taking <span class="math">\Gamma</span> and <span class="math">T</span>. The same logic applies for <span class="stt">type-infer</span>, which takes <span class="math">e</span>, <span class="math">\Gamma</span>,
and gives us <span class="math">T</span>.</p><p><div class="SIntrapara">So, let&rsquo;s write out our purpose statements and templates for these functions:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">type-check : ConcreteSyntax -&gt; ChkTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Produces a type checker for the given concrete term.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-check</span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-var</span><span class="hspace">&nbsp;</span><span class="RktSym">name</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-lam</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-app</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-ann</span><span class="hspace">&nbsp;</span><span class="RktSym">tm</span><span class="hspace">&nbsp;</span><span class="RktSym">tp</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">type-infer : ConcreteSyntax -&gt; SynTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Produces a type inferrer for the given concrete term.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-infer</span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-var</span><span class="hspace">&nbsp;</span><span class="RktSym">name</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-lam</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-app</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-ann</span><span class="hspace">&nbsp;</span><span class="RktSym">tm</span><span class="hspace">&nbsp;</span><span class="RktSym">tp</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Let&rsquo;s start with <span class="stt">type-check</span>. Note that the only tactic combinator we have (aside from <span class="stt">ann</span>) that
returns a <span class="stt">ChkTactic</span> is <span class="stt">introduce</span>, which takes a <span class="stt">ChkTactic</span> as input.</p><p><div class="SIntrapara">All the other pieces of syntax and their corresponding tactics return a <span class="stt">SynTactic</span>. We can use <span class="stt">chk</span>
to turn those into <span class="stt">ChkTactic</span>s. So, we fill it in, adding a fall-through for all other pieces of syntax:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">type-check : ConcreteSyntax -&gt; ChkTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Produces a type checker for the given concrete term.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-check</span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-lam</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">introduce</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-check</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-infer</span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">As for <span class="stt">type-infer</span>, we simply fill in the natural recursion (making all the types line up) for all
the syntaxes corresponding to combinators returning <span class="stt">SynTactic</span>s:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">type-infer : ConcreteSyntax -&gt; SynTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Produces a type inferrer for the given concrete term.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-infer</span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-var</span><span class="hspace">&nbsp;</span><span class="RktSym">name</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">name</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-lam</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-app</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">app</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-infer</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-check</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-ann</span><span class="hspace">&nbsp;</span><span class="RktSym">tm</span><span class="hspace">&nbsp;</span><span class="RktSym">tp</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ann</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-check</span><span class="hspace">&nbsp;</span><span class="RktSym">tm</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">tp</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">However, <span class="stt">introduce</span> returns a <span class="stt">ChkTactic</span>, and we can only turn a <span class="stt">ChkTactic</span> into a <span class="stt">SynTactic</span>
if we know what proposition it checks as. Consequently, we would need a type annotation, so we can&rsquo;t actually
infer any type, and we throw an error:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">type-infer : ConcreteSyntax -&gt; SynTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Produces a type inferrer for the given concrete term.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-infer</span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-var</span><span class="hspace">&nbsp;</span><span class="RktSym">name</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">name</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-app</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">app</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-infer</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-check</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">cs-ann</span><span class="hspace">&nbsp;</span><span class="RktSym">tm</span><span class="hspace">&nbsp;</span><span class="RktSym">tp</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">ann</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-check</span><span class="hspace">&nbsp;</span><span class="RktSym">tm</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">tp</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/exns.html#%28def._%28%28quote._~23~25kernel%29._error%29%29" class="RktValLink" data-pltdoc="x">error</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Writing.html#%28def._%28%28quote._~23~25kernel%29._format%29%29" class="RktValLink" data-pltdoc="x">format</a></span><span class="hspace">&nbsp;</span><span class="RktVal">"the term ~a needs more type annotations!"</span><span class="hspace">&nbsp;</span><span class="RktSym">stx</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">And we now have a fully functional type checker! Assuming your A1 is done, try out:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">run-chk</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">parse</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">A</span><span class="hspace">&nbsp;</span><span class="RktVal">&#8594;</span><span class="hspace">&nbsp;</span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">A</span><span class="hspace">&nbsp;</span><span class="RktVal">&#8594;</span><span class="hspace">&nbsp;</span><span class="RktVal">B</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">&#8594;</span><span class="hspace">&nbsp;</span><span class="RktVal">B</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">type-check</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cs-lam</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">a</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cs-lam</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cs-app</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cs-var</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cs-var</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">a</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">which should succeed (even if you haven&rsquo;t finished elaboration).</div></p><h4>3.5<tt>&nbsp;</tt><a name="(part._.Normalization_by_evaluation)"></a>Normalization by evaluation</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}
\newcommand{\fst}[1]{\mathsf{fst\ } #1}
\newcommand{\snd}[1]{\mathsf{snd\ } #1}</div></p><h5>3.5.1<tt>&nbsp;</tt><a name="(part._.Deciding_equivalence)"></a>Deciding equivalence</h5><p>We now shift topics to deciding if two lambda terms are equal, for the intuitive notion
of equality. Some of you are likely screaming "&#945;-equivalence", and this is somewhat correct.
Furthermore, since we decided to use DeBruijn levels, we already even have definitionally
alpha-equivalent terms, and don&rsquo;t have to worry about substitution.</p><p>However, consider the following:
<div class="math">(\lambda x. 2) 3 \stackrel{?}{\equiv} 2</div>
Well, this is intuitively true, right? We can perform a &#946;-reduction to make them equivalent.
But these terms aren&rsquo;t alpha-equivalent.</p><p>In general, to solve a problem like this, even in the case of
<div class="math">(\lambda x. y) (\lambda x. x) \stackrel{?}{\equiv} y</div>
we need to know a lot about the lambda calculus: we need to know whether or not <span class="math">y</span>
contains <span class="math">x</span> in its free variables, for one, we need to know its behavior when passed
<span class="math">\lambda x. x</span> as an argument...</p><p>So can we just compare the results of evaluation? Let&rsquo;s give it a shot.</p><h5>3.5.2<tt>&nbsp;</tt><a name="(part._.Data_definitions_for_.S.T.L.C)"></a>Data definitions for STLC</h5><p><div class="SIntrapara">First, we define a few of our important data definitions. We add <span class="stt">let</span> to our syntax:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Syntax is one of:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A DeBruijn *level*:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (syntax-local Number)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A lambda:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (syntax-lam Symbol Syntax)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A let-binding:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (syntax-let Symbol Syntax Syntax)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">An application:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (syntax-app Syntax Syntax)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">syntax-local</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">syntax-lam</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">syntax-let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._exp%29%29" class="RktValLink" data-pltdoc="x">exp</a></span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">syntax-app</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Since this is just simply-typed lambda calculus with no constants, our return value is going
to be a closure:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Closure is a (closure Syntax Environment)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">closure</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">term</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Value is a Closure</span></td></tr></table></blockquote></div><div class="SIntrapara">Finally, we need to actually define our environment, which is lazy for surprise reasons that will
help us later:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Environment is a [ListOf [PromiseOf Value]]</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">empty-env : -&gt; Environment</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">empty-env</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">extend-env : Environment [PromiseOf Value]] -&gt; Environment</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-env</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">apply-env : Environment Number -&gt; [PromiseOf Value]</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate/apply-env</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list-ref%29%29" class="RktValLink" data-pltdoc="x">list-ref</a></span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">env-size : Environment -&gt; Number</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">env-size</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._length%29%29" class="RktValLink" data-pltdoc="x">length</a></span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">as well as provide the usual 311-esque functions for environment usage.</div></p><h5>3.5.3<tt>&nbsp;</tt><a name="(part._.Building_terms_with_.De.Bruijn_levels__or__continuation_.H.O.A.S_)"></a>Building terms with DeBruijn levels (or: continuation HOAS)</h5><p>We need a bit of scaffolding to actually write out our terms with DeBruijn levels.
The upshot of DeBruijn indices is that we can very easily plug things, something we lose with
levels. However, we no longer have to do shifting math.</p><p><div class="SIntrapara">We define a <span style="font-style: italic">term builder</span>, which takes an environment size and gives us a corresponding
term with DeBruijn levels. To build terms, we will invoke the term builder to get a <span class="stt">Syntax</span>.
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A [TB X] is an [Number -&gt; X]</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">run-term-builder : {X} Environment [TB X] -&gt; X</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Produces the built core term, given an environment.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-term-builder</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">k</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">k</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">env-size</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>If you&rsquo;re cheeky, you may think of the continuation monad.</p><p>Yes.</p><p><div class="SIntrapara">Moving on, we first define a builder which is our base case for building these terms: given a DeBruijn
index, it shifts it to a level. (Note that we don&rsquo;t have to carry around indices: we&rsquo;ll see this in a bit.)
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">tb/var : Number -&gt; [TB Syntax]</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Given a DeBruijn index, produce a term builder giving a DeBruijn level in syntax.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/var</span><span class="hspace">&nbsp;</span><span class="RktSym">lvl</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">size</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syntax-local</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._-%29%29" class="RktValLink" data-pltdoc="x"><span class="nobreak">-</span></a></span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym">lvl</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">tb/var</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">3</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syntax-local</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/rackunit/api.html#%28def._%28%28lib._rackunit%2Fmain..rkt%29._check-equal~3f%29%29" class="RktValLink" data-pltdoc="x">check-equal?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">tb/var</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syntax-local</span><span class="hspace">&nbsp;</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">We then provide some more helpers that continue building the continuation, but increment the environment
size (thereby binding a variable):
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">tb/bind-var : {X} [Number -&gt; [TB X]] -&gt; [TB X]</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Take the given term-builder-builder, and increment its environment size.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/bind-var</span><span class="hspace">&nbsp;</span><span class="RktSym">k</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">size</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">k</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._%2B%29%29" class="RktValLink" data-pltdoc="x">+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">and one that scopes out a variable, binding it for a given body (noting that we represent the body as
taking a term-builder and returning a term-builder):
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">tb/scope : {X} [[TB Syntax] -&gt; [TB X]] -&gt; [TB X]</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Scopes out a variable, binding it for the given term-builder-builder.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/scope</span><span class="hspace">&nbsp;</span><span class="RktSym">k</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/bind-var</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">lvl</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">k</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/var</span><span class="hspace">&nbsp;</span><span class="RktSym">lvl</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Finally, we provide builders for let-bindings, lambdas, and applications. The former two take
functions from term builders to term builders, where the input to the function represents the bound
variable:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">tb/let : Symbol [TB Syntax] [[TB Syntax] -&gt; [TB Syntax]] -&gt; [TB Syntax]</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Build a let binding.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/let</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">size</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syntax-let</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">e</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">tb/scope</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">tb/lam : Symbol [[TB Syntax] -&gt; [TB Syntax]] -&gt; [TB Syntax]</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Build a lambda.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/lam</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">size</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syntax-lam</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">tb/scope</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">tb/app : [TB Syntax] [TB Syntax] -&gt; [TB Syntax]</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Build an application.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/app</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">size</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syntax-app</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rand</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">And voil&#225;, we have magic HOAS:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">church-zero</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/lam</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">f</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/lam</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">church-add1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/lam</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">n-1</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n-1</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/lam</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">f</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/lam</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/app</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/app</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tb/app</span><span class="hspace">&nbsp;</span><span class="RktSym">n-1</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">both of which evaluate to their representation with DeBruijn levels, and both of which cannot be illegally
scoped because of Racket&rsquo;s semantics.</div></p><h5>3.5.4<tt>&nbsp;</tt><a name="(part._.The_evaluator)"></a>The evaluator</h5><p><div class="SIntrapara">This should be pretty straightforward by now:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">evaluate : Syntax Environment -&gt; Value</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Evaluates the expression to a closure.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._exp%29%29" class="RktValLink" data-pltdoc="x">exp</a></span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._exp%29%29" class="RktValLink" data-pltdoc="x">exp</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">syntax-local</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Delayed_Evaluation.html#%28def._%28%28lib._racket%2Fpromise..rkt%29._force%29%29" class="RktValLink" data-pltdoc="x">force</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate/apply-env</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">syntax-lam</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closure</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">syntax-let</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._exp%29%29" class="RktValLink" data-pltdoc="x">exp</a></span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">unfold</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Delayed_Evaluation.html#%28form._%28%28lib._racket%2Fpromise..rkt%29._delay%29%29" class="RktStxLink" data-pltdoc="x">delay</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._exp%29%29" class="RktValLink" data-pltdoc="x">exp</a></span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate/extend-env</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">unfold</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">syntax-app</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate/do-app</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">evaluate/do-app : Value Value -&gt; Value</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Performs an application of the rator to the rand.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate/do-app</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match-define%29%29" class="RktStxLink" data-pltdoc="x">match-define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closure</span><span class="hspace">&nbsp;</span><span class="RktSym">tm</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym">tm</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-env</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Delayed_Evaluation.html#%28form._%28%28lib._racket%2Fpromise..rkt%29._delay%2Fstrict%29%29" class="RktStxLink" data-pltdoc="x">delay/strict</a></span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">The only primary difference is the <span class="RktSym"><a href="https://docs.racket-lang.org/reference/Delayed_Evaluation.html#%28form._%28%28lib._racket%2Fpromise..rkt%29._delay%29%29" class="RktStxLink" data-pltdoc="x">delay</a></span>, et al. These are promises, and produce a lazy value that can
be forced.</div></p><h5>3.5.5<tt>&nbsp;</tt><a name="(part._.Normal_forms)"></a>Normal forms</h5><p>In lambda calculus, both &#945;-equivalence (consistently renaming bound variables) and &#946;-reduction, written as:
<div class="math">(\lambda x. e_1)\ e_2 \equiv e_1[e_2/x]</div>
comprise a way of determining what terms are equal.</p><p><span style="font-weight: bold">Definition:</span> A <span style="font-style: italic">(&#946;-)normal form</span> is a form that has no <span style="font-style: italic">redexes</span>, or <span style="font-style: italic">reducible expressions</span>: so, no further substitution can be done.</p><p>One obvious way to perform normalization is to recursively search a piece of syntax for redexes, and reduce them
when possible. It&rsquo;s very elegant to think about when described in a single sentence. In practice, it is awful,
and the code is awful to read, and it performs terribly. Let&rsquo;s not do that and never discuss it again.</p><p><div class="SIntrapara">Instead, we can turn our closures back into lambdas, by a process called <span style="font-style: italic">quotation</span>
(or <span style="font-style: italic">reification</span>). To do this, we carefully limit our <span class="stt">Value</span> grammar to only capture normal forms:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Cut is a (value-cut Head [ListOf Form])</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">value-cut</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">head</span><span class="hspace">&nbsp;</span><span class="RktSym">spine</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Head is one of:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (value-local Number)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (value-let Number [PromiseOf Value])</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">value-local</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">value-let</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">n</span><span class="hspace">&nbsp;</span><span class="RktSym">promise</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Form is one of:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">(value-app Value)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">value-app</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">v</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Value is one of:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- Cut</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (value-lam String Closure)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">value-lam</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">name</span><span class="hspace">&nbsp;</span><span class="RktSym">closure</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">noting that this could be significantly simpler, but will become more complex as we add more eliminators.</div></p><p>Roughly, a <span class="stt">Value</span> represents a normal form as produced by the evaluator, a <span class="stt">Form</span> represents an
eliminator, a <span class="stt">Head</span> represents a neutral expression (which corresponds to variables that do not yet have a
value), and a <span class="stt">Cut</span> represents a stack of eliminators applied to some head.</p><p><div class="SIntrapara">So, let&rsquo;s change our evaluator to produce these. First, we write a couple of helpers that produce
the corresponding cuts:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">cut/local : Number -&gt; Cut</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cut/local</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">value-cut</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">value-local</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">cut/let-bind : Number [PromiseOf Value] -&gt; Cut</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cut/let-bind</span><span class="hspace">&nbsp;</span><span class="RktSym">lvl</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">value-cut</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">value-let</span><span class="hspace">&nbsp;</span><span class="RktSym">lvl</span><span class="hspace">&nbsp;</span><span class="RktSym">p</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">and then rewrite our evaluator:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">evaluate : Syntax Environment -&gt; Value</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Evaluates the expression to a neutral.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._exp%29%29" class="RktValLink" data-pltdoc="x">exp</a></span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._exp%29%29" class="RktValLink" data-pltdoc="x">exp</a></span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">syntax-local</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Delayed_Evaluation.html#%28def._%28%28lib._racket%2Fpromise..rkt%29._force%29%29" class="RktValLink" data-pltdoc="x">force</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">apply-env</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">syntax-lam</span><span class="hspace">&nbsp;</span><span class="RktSym">value</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">value-lam</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closure</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">syntax-let</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._exp%29%29" class="RktValLink" data-pltdoc="x">exp</a></span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">unfold</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cut/let-bind</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">env-size</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Delayed_Evaluation.html#%28form._%28%28lib._racket%2Fpromise..rkt%29._delay%29%29" class="RktStxLink" data-pltdoc="x">delay</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._exp%29%29" class="RktValLink" data-pltdoc="x">exp</a></span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym">body</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-env</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktSym">unfold</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">syntax-app</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">do-app</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">I&rsquo;m just going to put the rest of the code here, and talk over it in lecture.
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">evaluate/do-app : Value Value -&gt; Value</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate/do-app</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">value-lam</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">closure</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate/apply-closure</span><span class="hspace">&nbsp;</span><span class="RktSym">closure</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">value-cut</span><span class="hspace">&nbsp;</span><span class="RktSym">head</span><span class="hspace">&nbsp;</span><span class="RktSym">spine</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">push-form</span><span class="hspace">&nbsp;</span><span class="RktSym">rator</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">value-app</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">rator^</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate/do-app</span><span class="hspace">&nbsp;</span><span class="RktSym">rator^</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">evaluate/apply-closure : Closure Value -&gt; Value</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate/apply-closure</span><span class="hspace">&nbsp;</span><span class="RktSym">clo</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match-define%29%29" class="RktStxLink" data-pltdoc="x">match-define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">closure</span><span class="hspace">&nbsp;</span><span class="RktSym">tm</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">clo</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate</span><span class="hspace">&nbsp;</span><span class="RktSym">tm</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate/extend-env</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Delayed_Evaluation.html#%28form._%28%28lib._racket%2Fpromise..rkt%29._delay%2Fstrict%29%29" class="RktStxLink" data-pltdoc="x">delay/strict</a></span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">push-form : Cut Form [Value -&gt; Value] -&gt; Cut</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">push-form</span><span class="hspace">&nbsp;</span><span class="RktSym">cut</span><span class="hspace">&nbsp;</span><span class="RktSym">form</span><span class="hspace">&nbsp;</span><span class="RktSym">unfold</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match-define%29%29" class="RktStxLink" data-pltdoc="x">match-define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">value-cut</span><span class="hspace">&nbsp;</span><span class="RktSym">head</span><span class="hspace">&nbsp;</span><span class="RktSym">spine</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">cut</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">new-head</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">head</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">value-local</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">value-local</span><span class="hspace">&nbsp;</span><span class="RktSym">n</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">value-let</span><span class="hspace">&nbsp;</span><span class="RktSym">lvl</span><span class="hspace">&nbsp;</span><span class="RktSym">promise</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">value-let</span><span class="hspace">&nbsp;</span><span class="RktSym">lvl</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Delayed_Evaluation.html#%28form._%28%28lib._racket%2Fpromise..rkt%29._delay%29%29" class="RktStxLink" data-pltdoc="x">delay</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">unfold</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Delayed_Evaluation.html#%28def._%28%28lib._racket%2Fpromise..rkt%29._force%29%29" class="RktValLink" data-pltdoc="x">force</a></span><span class="hspace">&nbsp;</span><span class="RktSym">promise</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">value-cut</span><span class="hspace">&nbsp;</span><span class="RktSym">new-head</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">form</span><span class="hspace">&nbsp;</span><span class="RktSym">spine</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">QUOTATION</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">reify-bind-var : {X} PositiveInteger [PositiveInteger Value -&gt; X] -&gt; X</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify-bind-var</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym">k</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">k</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._add1%29%29" class="RktValLink" data-pltdoc="x">add1</a></span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">cut/local</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">reify : PositiveInteger Value -&gt; Syntax</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">val</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">value-cut</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify-cut</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym">val</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">value-lam</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktSym">closure</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syntax-lam</span><span class="hspace">&nbsp;</span><span class="RktSym">var</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify-closure</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym">closure</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">reify-cut : PositiveInteger Cut -&gt; Syntax</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify-cut</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym">cut</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match-define%29%29" class="RktStxLink" data-pltdoc="x">match-define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">value-cut</span><span class="hspace">&nbsp;</span><span class="RktSym">head</span><span class="hspace">&nbsp;</span><span class="RktSym">spine</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">cut</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify-spine</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify-head</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym">head</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">spine</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">reify-spine : PositiveInteger Syntax [ListOf Form] -&gt; Syntax</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify-spine</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._exp%29%29" class="RktValLink" data-pltdoc="x">exp</a></span><span class="hspace">&nbsp;</span><span class="RktSym">spine</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">spine</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._exp%29%29" class="RktValLink" data-pltdoc="x">exp</a></span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">form</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify-spine</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify-form</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._exp%29%29" class="RktValLink" data-pltdoc="x">exp</a></span><span class="hspace">&nbsp;</span><span class="RktSym">form</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Flist..rkt%29._rest%29%29" class="RktValLink" data-pltdoc="x">rest</a></span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">reify-form : PositiveInteger Syntax Form -&gt; Syntax</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify-form</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._exp%29%29" class="RktValLink" data-pltdoc="x">exp</a></span><span class="hspace">&nbsp;</span><span class="RktSym">form</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">form</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">value-app</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syntax-app</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/generic-numbers.html#%28def._%28%28quote._~23~25kernel%29._exp%29%29" class="RktValLink" data-pltdoc="x">exp</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym">rand</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">reify-head : PositiveInteger Head -&gt; Syntax</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify-head</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym">head</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span><span class="hspace">&nbsp;</span><span class="RktSym">head</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">value-local</span><span class="hspace">&nbsp;</span><span class="RktSym">lvl</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syntax-local</span><span class="hspace">&nbsp;</span><span class="RktSym">lvl</span><span class="RktPn">)</span><span class="RktPn">]</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">[</span><span class="RktPn">(</span><span class="RktSym">value-let</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29.__%29%29" class="RktStxLink" data-pltdoc="x">_</a></span><span class="hspace">&nbsp;</span><span class="RktSym">unfold</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/Delayed_Evaluation.html#%28def._%28%28lib._racket%2Fpromise..rkt%29._force%29%29" class="RktValLink" data-pltdoc="x">force</a></span><span class="hspace">&nbsp;</span><span class="RktSym">unfold</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">reify-closure : PositiveInteger Closure -&gt; Syntax</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify-closure</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span><span class="hspace">&nbsp;</span><span class="RktSym">closure</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify-bind-var</span><span class="hspace">&nbsp;</span><span class="RktSym">size</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">size^</span><span class="hspace">&nbsp;</span><span class="RktSym">arg</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">reify</span><span class="hspace">&nbsp;</span><span class="RktSym">size^</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">evaluate/apply-closure</span><span class="hspace">&nbsp;</span><span class="RktSym">closure</span><span class="hspace">&nbsp;</span><span class="RktSym">arg</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>Yeah.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Course_calendar.html" title="backward to &quot;2 Course calendar&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;B629 Spring 2023 -- Proofs as Programs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Assignments.html" title="forward to &quot;4 Assignments&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>