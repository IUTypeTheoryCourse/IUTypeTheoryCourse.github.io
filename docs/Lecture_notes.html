<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>2&nbsp;Lecture notes</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {document.write('<scr' + 'ipt type="text/javascript" src="MathJax/MathJax.js?config=default"></scr' + 'ipt>');})();
</script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">B629 Spring 2023 &ndash; Proofs as Programs</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lecture notes</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="Worksheets.html" class="tocviewlink" data-pltdoc="x">Worksheets</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>2&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Lecture notes</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">2.1&nbsp;</td><td><a href="#%28part._.Propositional_logic%29" class="tocviewlink" data-pltdoc="x">Propositional logic</a></td></tr><tr><td align="right">2.2&nbsp;</td><td><a href="#%28part._.Designing_tactics%29" class="tocviewlink" data-pltdoc="x">Designing tactics</a></td></tr><tr><td align="right">2.3&nbsp;</td><td><a href="#%28part._.Elaboration%29" class="tocviewlink" data-pltdoc="x">Elaboration</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Propositional_logic%29" class="tocsubseclink" data-pltdoc="x">Propositional logic</a></td></tr><tr><td><span class="tocsublinknumber">2.1.1<tt>&nbsp;</tt></span><a href="#%28part._.The_syllabus%29" class="tocsubseclink" data-pltdoc="x">The syllabus</a></td></tr><tr><td><span class="tocsublinknumber">2.1.2<tt>&nbsp;</tt></span><a href="#%28part._.Philosophical_foundations_of_type_theory%29" class="tocsubseclink" data-pltdoc="x">Philosophical foundations of type theory</a></td></tr><tr><td><span class="tocsublinknumber">2.1.3<tt>&nbsp;</tt></span><a href="#%28part._.Classical_propositional_logic__semantics%29" class="tocsubseclink" data-pltdoc="x">Classical propositional logic:<span class="mywbr"> &nbsp;</span> semantics</a></td></tr><tr><td><span class="tocsublinknumber">2.1.4<tt>&nbsp;</tt></span><a href="#%28part._.Natural_deduction%29" class="tocsubseclink" data-pltdoc="x">Natural deduction</a></td></tr><tr><td><span class="tocsublinknumber">2.1.5<tt>&nbsp;</tt></span><a href="#%28part._.Classical_propositional_logic__proof_system%29" class="tocsubseclink" data-pltdoc="x">Classical propositional logic:<span class="mywbr"> &nbsp;</span> proof system</a></td></tr><tr><td><span class="tocsublinknumber">2.1.6<tt>&nbsp;</tt></span><a href="#%28part._.Intuitionistic_propositional_logic%29" class="tocsubseclink" data-pltdoc="x">Intuitionistic propositional logic</a></td></tr><tr><td><span class="tocsublinknumber">2.1.7<tt>&nbsp;</tt></span><a href="#%28part._.The_.B.H.K_interpretation%29" class="tocsubseclink" data-pltdoc="x">The BHK interpretation</a></td></tr><tr><td><span class="tocsublinknumber">2.1.8<tt>&nbsp;</tt></span><a href="#%28part._.Intuitionistic_propositional_logic__proof_system%29" class="tocsubseclink" data-pltdoc="x">Intuitionistic propositional logic:<span class="mywbr"> &nbsp;</span> proof system</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.Designing_tactics%29" class="tocsubseclink" data-pltdoc="x">Designing tactics</a></td></tr><tr><td><span class="tocsublinknumber">2.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Tactics%29" class="tocsubseclink" data-pltdoc="x">Tactics</a></td></tr><tr><td><span class="tocsublinknumber">2.2.2<tt>&nbsp;</tt></span><a href="#%28part._.Tactics_in_.Racket%29" class="tocsubseclink" data-pltdoc="x">Tactics in Racket</a></td></tr><tr><td><span class="tocsublinknumber">2.2.3<tt>&nbsp;</tt></span><a href="#%28part._.Our_first_example__variable_references%29" class="tocsubseclink" data-pltdoc="x">Our first example:<span class="mywbr"> &nbsp;</span> variable references</a></td></tr><tr><td><span class="tocsublinknumber">2.2.4<tt>&nbsp;</tt></span><a href="#%28part._.Examples__conversion_and_annotation%29" class="tocsubseclink" data-pltdoc="x">Examples:<span class="mywbr"> &nbsp;</span> conversion and annotation</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._.Elaboration%29" class="tocsubseclink" data-pltdoc="x">Elaboration</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.7.0.8</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Syllabus.html" title="backward to &quot;1 Syllabus&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;B629 Spring 2023 -- Proofs as Programs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Assignments.html" title="forward to &quot;3 Assignments&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>2<tt>&nbsp;</tt><a name="(part._.Lecture_notes)"></a>Lecture notes</h3><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Propositional_logic%29" class="toclink" data-pltdoc="x">2.1<span class="hspace">&nbsp;</span>Propositional logic</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Designing_tactics%29" class="toclink" data-pltdoc="x">2.2<span class="hspace">&nbsp;</span>Designing tactics</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Elaboration%29" class="toclink" data-pltdoc="x">2.3<span class="hspace">&nbsp;</span>Elaboration</a></p></td></tr></table><h4>2.1<tt>&nbsp;</tt><a name="(part._.Propositional_logic)"></a>Propositional logic</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}</div></p><h5>2.1.1<tt>&nbsp;</tt><a name="(part._.The_syllabus)"></a>The syllabus</h5><p>Go over the premise of the course and go over the beats of the course.
All of this content is in the syllabus. Have you read the syllabus? You
should read the syllabus. If you&rsquo;re reading this paragraph, you should
be reading the syllabus instead.</p><h5>2.1.2<tt>&nbsp;</tt><a name="(part._.Philosophical_foundations_of_type_theory)"></a>Philosophical foundations of type theory</h5><p>The first rule of type theory is you don&rsquo;t ask what a type is.</p><p>In set theory, when we say a statement like <span class="math">2 \in \mathbb{N}</span>, you&rsquo;re
making a statement about <span class="math">\mathbb{N}</span> &#8212;<wbr></wbr> we postulated the existence of
this inductive set with infinitely many elements, and however we chose to
represent <span class="math">2</span> was part of that inductively defined set.</p><p>In type theory, the definition of <span class="math">\mathbb{N}</span> looks a lot more like a
description: we add two rules to our theory,</p><p><div class="math">\ir{}{}{\Gamma \vdash \mathrm{zero} : \mathbb{N}} ~~
\ir{}{\Gamma \vdash m : \mathbb{N}}{\Gamma \vdash \mathrm{suc}\ m : \mathbb{N}}</div></p><p>both of which describe what <span style="font-style: italic">is</span> a natural number.</p><p>Don&rsquo;t worry about what these mean yet, but you can read it as "under any context,
zero is a natural number", and "if under some context, <span class="math">m</span> is a natural number,
then <span class="math">\mathrm{suc\ } m</span> is a natural number".</p><p>When we say that <span class="math">2 : \mathbb{N}</span>, then, we&rsquo;re saying that
<span class="math">\mathrm{suc\ (suc\ zero)} : \mathbb{N}</span>, which makes a statement about <span class="math">2</span>.</p><p>This is useful because in set theory, the intuition is you&rsquo;ve constructed an
infinitely large set of things, and to check membership you just traverse that
infinite set. Computers are really bad at doing anything that&rsquo;s infinite.
(Obviously, there are ways of axiomatizing set theory that avoid this. The point
is that the philosophy of type theory is more compatible with computer-aided
proof.)</p><h5>2.1.3<tt>&nbsp;</tt><a name="(part._.Classical_propositional_logic__semantics)"></a>Classical propositional logic: semantics</h5><p><div class="SIntrapara"><span style="font-weight: bold">Definition:</span> Propositional logic is defined by the grammar:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td align="right" valign="baseline"><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">prop-expr</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">var</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktVar">prop-expr</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8743;</span><span class="hspace">&nbsp;</span><span class="RktVar">prop-expr</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktVar">prop-expr</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8744;</span><span class="hspace">&nbsp;</span><span class="RktVar">prop-expr</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktVar">prop-expr</span><span class="hspace">&nbsp;</span><span class="RktSym">&#8594;</span><span class="hspace">&nbsp;</span><span class="RktVar">prop-expr</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">&#172;</span><span class="hspace">&nbsp;</span><span class="RktVar">prop-expr</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">where <span class="stt">var</span> is some set of atomic symbols representing the variables.</div></p><p><div class="SIntrapara">Classical propositional logic deals with notions of "true" and "false", and the
semantics of it are truth-tables. As an example:
</div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" style="border-collapse: collapse;"><tr><td align="center" style="border-bottom: 1px solid black;"><p><span class="math">A</span></p></td><td align="center" style="border-bottom: 1px solid black;"><p><span class="math">B</span></p></td><td align="center" style="border-bottom: 1px solid black;"><p><span class="math">A \to B</span></p></td></tr><tr><td align="center"><p><span class="math">\mathsf{T}</span></p></td><td align="center"><p><span class="math">\mathsf{T}</span></p></td><td align="center"><p><span class="math">\mathsf{T}</span></p></td></tr><tr><td align="center"><p><span class="math">\mathsf{T}</span></p></td><td align="center"><p><span class="math">\mathsf{F}</span></p></td><td align="center"><p><span class="math">\mathsf{F}</span></p></td></tr><tr><td align="center"><p><span class="math">\mathsf{F}</span></p></td><td align="center"><p><span class="math">\mathsf{T}</span></p></td><td align="center"><p><span class="math">\mathsf{T}</span></p></td></tr><tr><td align="center"><p><span class="math">\mathsf{F}</span></p></td><td align="center"><p><span class="math">\mathsf{F}</span></p></td><td align="center"><p><span class="math">\mathsf{T}</span></p></td></tr></table></div><div class="SIntrapara">where each truth value has a different meaning for each propositional connective.
(We went over each connective, and worked some examples.)</div></p><p><span style="font-weight: bold">Definition:</span> A <span style="font-style: italic">valuation</span> is a function
<span class="math">v : \mathsf{Var} \to \{\mathsf{T}, \mathsf{F}\}</span> that assigns meaning to each
variable. Given a valuation <span class="math">v</span> and a <span class="stt">prop-expr</span> <span class="math">e</span>, we write
<span class="math">\semantics{e}_v</span> to mean "the meaning of <span class="math">e</span> under the valuation <span class="math">v</span>".</p><p>We define the meaning of <span class="math">\semantics{e}_v</span> recursively for each connective:
<div class="math">\begin{align*}
  \semantics{X}_v &amp;= v(X), \mathrm{when\ } X \in \mathsf{Var} \\
  \semantics{X \land Y}_v &amp;= \semantics{X}_v \land \semantics{Y}_v \\
  \semantics{X \lor Y}_v &amp;= \semantics{X}_v \lor \semantics{Y}_v \\
  \semantics{X \to Y}_v &amp;= \semantics{X}_v \to \semantics{Y}_v \\
  \semantics{\neg X}_v &amp;= \neg \semantics{X}_v
\end{align*}</div>
where each connective on booleans is defined as usual.</p><p><span style="font-weight: bold">Definition:</span> A <span class="stt">prop-expr</span> <span class="math">e</span> is a <span style="font-style: italic">tautology</span> if
for all valuations <span class="math">v</span>, <span class="math">\semantics{e}_v = \mathsf{T}</span>.</p><p><span style="font-weight: bold">Definition:</span> <span class="math">e</span> is <span style="font-style: italic">satisfiable</span> if there is a valuation
<span class="math">v</span> such that <span class="math">\semantics{e}_v = \mathsf{T}</span>.</p><p><span style="font-weight: bold">Definition:</span> <span class="math">e</span> is a <span style="font-style: italic">contradiction</span> if there is no valuation
<span class="math">v</span> such that <span class="math">\semantics{e}_v = \mathsf{T}</span>, or in other words, if for
all valuations <span class="math">v</span>, <span class="math">\semantics{e}_v = \mathsf{F}</span>.</p><h5>2.1.4<tt>&nbsp;</tt><a name="(part._.Natural_deduction)"></a>Natural deduction</h5><p>In H241 (note: not C241), M384, et cetera, you would have been exposed to Fitch-style
natural deduction proofs.
We will not be doing those, instead opting for Gentzen-style natural deduction.</p><p>Natural deduction systems are comprised of <span style="font-style: italic">inference rules</span>, which look
like this:
<div class="math">\ir{}{\mathrm{assumption\ 1} ~~~ \mathrm{assumption\ 2} ~~~ \ldots ~~~ \mathrm{assumption\ } n}{\mathrm{consequent}}</div>
where everything above the line is something we already know, and the single thing below
the line is something we get as a result.</p><p><div class="SIntrapara">All of our connectives will have one of four (or five) types of associated rules:
</div><div class="SIntrapara"><ul><li><p><span style="font-weight: bold">Formation:</span> How to form a proposition syntactically. For example, given that <span class="math">A</span> is a
proposition and <span class="math">B</span> is a proposition, then <span class="math">A \to B</span> is a proposition. This effectively describes
the grammar of our logic.</p></li><li><p><span style="font-weight: bold">Introduction:</span> How to construct a proof of a given proposition. For example,
given that we have a proof of <span class="math">A</span> and a proof of <span class="math">B</span>, then we can construct a proof of <span class="math">A \land B</span>.</p></li><li><p><span style="font-weight: bold">Elimination:</span> How to get things from a proof of a given proposition. For example, given that
we have a proof of <span class="math">A \land B</span>, we can get a proof of <span class="math">B</span>.</p></li><li><p><span style="font-weight: bold">Computation:</span> We will discuss this later in the course.</p></li><li><p><span style="font-weight: bold">Uniqueness:</span> We will discuss this later in the course.</p></li></ul></div></p><h5>2.1.5<tt>&nbsp;</tt><a name="(part._.Classical_propositional_logic__proof_system)"></a>Classical propositional logic: proof system</h5><p>The formation rules are effectively the same as our grammar for <span class="stt">prop-expr</span> in Exercise 1, and will
be ommitted for now, but, for example, they look like this:
<div class="math">\ir{(\land_{\mathrm{form}})}{A \mathrm{\ prop} ~~~ B \mathrm{\ prop}}{A \land B \mathrm{\ prop}} ~~~
\ir{(\bot_{\mathrm{form}})}{}{\bot \mathrm{\ prop}}</div></p><p>Implication is by far the most complex of our connectives, as with our current formulation of inference
rules, we have no good way of stating a Gentzen-style rule for <span class="math">\to_\mathrm{intro}</span>.
So, we will state elimination first:
<div class="math">\ir{(\to_{\mathrm{elim}})}{A \to B ~~~ A}{B}</div>
This is often called "modus ponens", and it says that if <span class="math">A</span> implies <span class="math">B</span>, and also <span class="math">A</span>, then we have
<span class="math">B</span>.</p><p>Implication introduction requires more things in our proof system. Intuitively, <span class="math">A \to B</span> is true if,
when we assume <span class="math">A</span>, then we can derive <span class="math">B</span>. We don&rsquo;t have any notion of "assuming" in natural deduction
yet, so we need to add some extra things to our system.</p><p>Our introduction rule therefore looks like this:
<div class="math">\ir{(\to_{\mathrm{intro}})}
   {\begin{matrix}
      \ir{}{}{A} \\
      \vdots \\
      B
    \end{matrix}}
   {A \to B}</div>
where the <span class="math">\vdots</span> represents a <span style="font-style: italic">hypothetical derivation</span>. We will be revisiting this very soon.</p><p>This can be read as "we assume <span class="math">A</span>, and then derive <span class="math">B</span>" means that "if <span class="math">A</span>, then <span class="math">B</span>".</p><p>For conjunction, the inference rules are:
<div class="math">\ir{(\land_{\mathrm{intro}})}{A ~~~ B}{A \land B} ~~~
\ir{(\land_{\mathrm{elim}0})}{A \land B}{A} ~~~
\ir{(\land_{\mathrm{elim}1})}{A \land B}{B}</div>
which are relatively straightforward to reason about: if both <span class="math">A</span> and <span class="math">B</span>, then <span class="math">A \land B</span>,
and if <span class="math">A \land B</span>, then both <span class="math">A</span> and <span class="math">B</span>.</p><p>For disjunction, the inference rules are:
<div class="math">\ir{(\lor_{\mathrm{intro}0})}{A}{A \lor B} ~~~
\ir{(\lor_{\mathrm{intro}1})}{B}{A \lor B} ~~~
\ir{(\lor_{\mathrm{elim}})}{A \lor B ~~~ A \to C ~~~ B \to C}{C}</div>
which require a bit more justification. If <span class="math">A</span>, then obviously <span class="math">A \lor B</span>, and the same for
<span class="math">B</span> then <span class="math">A \lor B</span>.</p><p>For negation, we <span style="font-style: italic">define</span> <span class="math">\neg A</span> to be <span class="math">A \to \bot</span> (where that symbol is read as
"bottom"). This is the first serious departure from most expositions of propositional logic, so
make a note of it.</p><p><span class="math">\bot</span> intentionally does not have an introduction rule, as it represents a contradiction.
Note that, with this definition, we can prove the <span style="font-style: italic">law of non-contradiction</span>: that
<span class="math">\neg (A \land \neg A)</span>:
<div class="math">\ir{(\to_{\mathrm{elim}})}
   {\ir{(\land_{\mathrm{elim}1})}{A \land (A \to \bot)}{A \to \bot} ~~~
    \ir{(\land_{\mathrm{elim}0})}{A \land (A \to \bot)}{A}}
   {\bot}</div>
(noting that I implicitly use implication introduction for simplicity.)</p><p>We have two rules for dealing with <span class="math">\bot</span>:
<div class="math">\ir{(\bot_{\mathrm{elim}})}{\bot}{A} ~~~
\ir{(\mathsf{DNE})}{\neg \neg A}{A}</div>
referred to as the principle of explosion/ex falso, and double-negation elimination, respectively.
In essence, this states that if we can prove <span class="math">\bot</span>, we can prove anything. Double-negation
should seem intuitively sensible under the Boolean interpretation.</p><h5>2.1.6<tt>&nbsp;</tt><a name="(part._.Intuitionistic_propositional_logic)"></a>Intuitionistic propositional logic</h5><p>We exposited the proof system for classical propositional logic, in which the truth
values correspond to the Boolean semantics, last lecture.</p><p>We will not be discussing the semantics of IPL: if you are interested, you should look
at Kripke models and realizability. (See LACI, 2.9)</p><p>The philosophical foundation for constructive mathematics, the primary topic of this course, is
that if something is true, you should be able to hand me a witness to that truth. This is based
in the notion of intuitionism, which says, in the loosest sense, that what is true is what you
can convince me is true.</p><p>If we downplay the notion of objective truth and whether or not our semantics can show if something
is a tautology, we can instead reason more about what proofs <span style="font-style: italic">are</span>.</p><h5>2.1.7<tt>&nbsp;</tt><a name="(part._.The_.B.H.K_interpretation)"></a>The BHK interpretation</h5><p>The Brouwer-Heyting-Kolmogorov (BHK interpretation) is a way of assigning what a proof is &#8212;<wbr></wbr> as in,
the BHK interpretation of a formula is a kind of object you can hand to me to discern whether the
formula is true or not.</p><p><div class="SIntrapara"><span style="font-weight: bold">Definition:</span> We define the BHK interpretation of a formula inductively on connectives:
</div><div class="SIntrapara"><ul><li><p><span class="math">X \to Y</span> is interpreted as a function which, given a proof of <span class="math">X</span>, produces a proof of <span class="math">Y</span>.</p></li><li><p><span class="math">X \land Y</span> is interpreted as a pair <span class="math">(a, b)</span>, where <span class="math">a</span> is a proof of <span class="math">X</span> and <span class="math">b</span> is a proof
of <span class="math">Y</span>.</p></li><li><p><span class="math">X \lor Y</span> is either <span class="math">(0, a)</span> where <span class="math">a</span> is a proof of ${X}, or <span class="math">(1, b)</span> where <span class="math">b</span> is a proof
of <span class="math">Y</span>.</p></li><li><p><span class="math">\neg X</span> is still defined as <span class="math">X \to \bot</span>.</p></li><li><p><span class="math">\bot</span> has no proof.</p></li></ul></div></p><p>As an example, suppose that I wanted to prove <span class="math">(A \land \neg A) \to \bot</span>, otherwise known as the law of
non-contradiction. Then, I would want to construct a function from <span class="math">A \land \neg A</span> to <span class="math">\bot</span>.</p><p><span class="math">A \land \neg A</span> is interpreted as a pair of proofs for <span class="math">A</span> and <span class="math">\neg A</span>, and <span class="math">\neg A</span> is interpreted
as a function <span class="math">A \to \bot</span>.</p><p>So, the function <span class="math">f((a, n)) = n(a)</span> is a witness to <span class="math">(A \land \neg A) \to \bot</span> under the BHK interpretation.</p><h5>2.1.8<tt>&nbsp;</tt><a name="(part._.Intuitionistic_propositional_logic__proof_system)"></a>Intuitionistic propositional logic: proof system</h5><p>In the last lecture, we wrote down a set of rules for classical propositional logic. The set of Gentzen-style
rules for IPL are exactly the same, except without the rule <span class="math">\mathsf{DNE}</span>.</p><p>Why is this the case? Note that in the BHK interpretation, there is not a clear way to construct a witness to
<span class="math">\neg \neg A \to A</span>. The only thing we have is a function, the only way we can eliminate a function is to
apply it to an argument, and we have no means to conjure an argument to our function out of thin air.</p><p>Tying this proof system to the BHK interpretation is the work of <span style="font-style: italic">elaboration</span>, a later topic in this
course.</p><h4>2.2<tt>&nbsp;</tt><a name="(part._.Designing_tactics)"></a>Designing tactics</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}</div></p><h5>2.2.1<tt>&nbsp;</tt><a name="(part._.Tactics)"></a>Tactics</h5><p>We now have a proof system for IPL. We would like to write code that actually verifies our proofs.
To try and create this correspondence, we define a kind of reusable checker, known as a tactic.</p><p><span style="font-weight: bold">Definition:</span> A <span style="font-style: italic">context</span>, usually denoted by <span class="math">\Gamma</span>, is an association of names of witnesses
to the propositions they prove. So, the empty context represents no assumptions, and the context
<span class="math">x : A, y : B</span> represents a witness named <span class="math">x</span> that proves <span class="math">A</span>, and a witness named <span class="math">y</span> that proves
<span class="math">B</span>.</p><p><span style="font-style: italic">Note:</span> This is very similar to the notion of an environment from 311.</p><p><span style="font-weight: bold">Definition:</span> A <span style="font-style: italic">check tactic</span>, or <span class="stt">ChkTactic</span> in code, is a function <span class="stt">Context Prop -&gt; Void</span>
that, given a context and a proposition, does nothing if it can prove the proposition under the context, and
errors if it cannot.</p><p><span style="font-weight: bold">Definition:</span> An <span style="font-style: italic">infer tactic</span>, or <span class="stt">SynTactic</span> in code, is a function <span class="stt">Context -&gt; Prop</span>
that, given a context, returns the proposition that it proves.</p><p>We define <span style="font-style: italic">tactic combinators</span>, functions that take and return tactics, to represent each rule. This
leads us to the <span style="font-weight: bold">design recipe for tactics:</span></p><p><div class="SIntrapara">Given an inference rule:
</div><div class="SIntrapara"><ol><li><p><span style="font-weight: bold">Determine your output.</span> As a general rule of thumb, introduction rules turn into check tactics,
and elimination rules turn into infer tactics.</p></li><li><p><span style="font-weight: bold">Solve your unknowns.</span> Determine what information above the line needs to be present to check
or infer the proposition that you need.</p></li><li><p><span style="font-weight: bold">Signature.</span> All the things above the line turn into inputs, with their type depending
on step 2, and your output turns into your return type.</p></li><li><p><span style="font-weight: bold">Design your function.</span> This means writing tests, determining how it fits in with other tactics.</p></li><li><p><span style="font-weight: bold">Test.</span></p></li></ol></div></p><p>Most of the first few steps will be given to you for assignments 1 and 2, primarily because we do not yet have
the machinery to make well-informed decisions on what should be a check tactic versus an infer tactic.</p><h5>2.2.2<tt>&nbsp;</tt><a name="(part._.Tactics_in_.Racket)"></a>Tactics in Racket</h5><p>First, we provide our data definition and helper function for a context.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Context is a [Listof [Pairof Symbol Prop]]</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">extend-context : Context Symbol Prop -&gt; Context</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Adds a witness of the given proposition to the context.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">name</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktSym">name</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktVal">`</span><span class="RktVal">(</span><span class="RktVal">(</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktVal">. </span><span class="RktRdr">,</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktVal">)</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="RktValLink" data-pltdoc="x">cons</a></span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote><p>Note that this is effectively the same as the data-structural representation of an environment from 311: we
define it as an association list instead of a tagged list, however.</p><p><div class="SIntrapara">We then define tactics not solely as their underlying function, but as a structure that can be called as
a function:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A ChkTactic is a (chk-tactic Symbol [Context Prop -&gt; Void])</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A SynTactic is a (syn-tactic Symbol [Context -&gt; Prop])</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">chk-tactic</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">name</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:transparent</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:property</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._prop~3aprocedure%29%29" class="RktValLink" data-pltdoc="x">prop:procedure</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct-field-index%29%29" class="RktStxLink" data-pltdoc="x">struct-field-index</a></span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">syn-tactic</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">name</span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:transparent</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">#:property</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._prop~3aprocedure%29%29" class="RktValLink" data-pltdoc="x">prop:procedure</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct-field-index%29%29" class="RktStxLink" data-pltdoc="x">struct-field-index</a></span><span class="hspace">&nbsp;</span><span class="RktSym">f</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">run-chk : Prop ChkTactic -&gt; Void</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Runs the given check tactic on the input proposition.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-chk</span><span class="hspace">&nbsp;</span><span class="RktSym">goal</span><span class="hspace">&nbsp;</span><span class="RktSym">tactic</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tactic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktSym">goal</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">run-syn : SynTactic -&gt; Prop</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Runs the given synthesis tactic, producing the proposition it witnesses.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">run-syn</span><span class="hspace">&nbsp;</span><span class="RktSym">tactic</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tactic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>We define these using <span class="RktSym"><a href="https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._prop~3aprocedure%29%29" class="RktValLink" data-pltdoc="x">prop:procedure</a></span> for one reason: it is very advantageous to have error messages
reference both the name of the input tactic (which is what the <span class="stt">name</span> field is for), and it makes our
contracts significantly easier to write while also referencing <span class="RktSym">chk-tactic?</span> rather than a function
contract.</p><p>The <span class="RktSym">run-chk</span> and <span class="RktSym">run-syn</span> functions are merely wrappers that run the tactics on empty contexts.
These are usually used for top-level proofs, as we will see later.</p><h5>2.2.3<tt>&nbsp;</tt><a name="(part._.Our_first_example__variable_references)"></a>Our first example: variable references</h5><p>We first design our very first rule, which we need to be able to have a base case. All of our tactic
<span style="font-style: italic">combinators</span> take other tactics as inputs, but we need some tactic that does not depend on other tactics.</p><p>We have our <span class="stt">Context</span>, which maps names of witnesses to their propositions. However, we need a way to turn
one of those witnesses into a tactic that can be provided to combinators.
So, we start by noting that we have no tactics as inputs, and that we will be returning a <span class="stt">SynTactic</span>,
as (by the next section) we can turn a <span class="stt">SynTactic</span> into a <span class="stt">ChkTactic</span> easily, but not the other way
around.</p><p><div class="SIntrapara">So, the signature of our function is <span class="stt">assumption : Symbol -&gt; SynTactic</span>. We now write our purpose statement
and template:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">assumption : Symbol -&gt; SynTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *variable rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given a witness x of P in the context,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">returns a tactic corresponding to x.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._symbol~3f%29%29" class="RktValLink" data-pltdoc="x">symbol?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">syn-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assumption</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">Then, we write some tests. Given a context where <span class="math">x : B</span>, we want to return the proposition <span class="math">B</span>. So,
we write tests that codify that:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-equal?</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8594;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8594;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-error</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">We then use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/dicts.html#%28def._%28%28lib._racket%2Fdict..rkt%29._dict-ref%29%29" class="RktValLink" data-pltdoc="x">dict-ref</a></span> to fill in our function body, which does what it says on the tin:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">assumption : Symbol -&gt; SynTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *variable rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given a witness x of P in the context,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">imbues x with being a witness of P.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/symbols.html#%28def._%28%28quote._~23~25kernel%29._symbol~3f%29%29" class="RktValLink" data-pltdoc="x">symbol?</a></span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">syn-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">assumption</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/dicts.html#%28def._%28%28lib._racket%2Fdict..rkt%29._dict-ref%29%29" class="RktValLink" data-pltdoc="x">dict-ref</a></span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">s</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">and all our tests pass.</div></p><h5>2.2.4<tt>&nbsp;</tt><a name="(part._.Examples__conversion_and_annotation)"></a>Examples: conversion and annotation</h5><p>Let&rsquo;s work on some of the most basic rules we need in a system like this. Given a check tactic,
to make our types line up with all of our combinators, we need to be able to create an infer tactic, and vice
versa.</p><p>We use the <span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span> form to state our signatures and have them checked at runtime, as it
results in errors that yell about what tactic you used and whether or not it was a check/infer tactic, rather
than incomprehensible errors about procedure arity.</p><p>So, we will implement a tactic combinator <span class="stt">chk : SynTactic -&gt; ChkTactic</span>, which takes an infer tactic
and produces a check tactic with the same behavior. So, given that we have a witness <span style="font-style: italic">of</span> <span class="math">P</span>, we can
create a witness that <span style="font-style: italic">checks as</span> <span class="math">P</span>.</p><p>Steps 1, 2, and 3 of our design recipe are trivial.</p><p><div class="SIntrapara">As for step 4, we begin by writing our our purpose statement, contract, and template:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">chk : SynTactic -&gt; ChkTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *conversion rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given that t is a witness of the proposition P,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">then t is also able to be checked as a witness of P.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktSym">tac</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic?</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">chk-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">chk</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">goal</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">We now need to write some tests. The only base tactic we have is <span class="stt">assumption</span>, so we simply turn
it into a <span class="stt">ChkTactic</span> using our combinator and see what happens:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/module.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._module%2B%29%29" class="RktStxLink" data-pltdoc="x">module+</a></span><span class="hspace">&nbsp;</span><span class="RktSym">test</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">extend-context</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8594;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-success</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">A</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-success</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">y</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8594;</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-atomic</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">B</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-error</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">z</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">check-error</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assumption</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">x</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">ctx</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">prop-&#8869;</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>So, we begin our game of type tetris to fill in the definition. We know that <span class="stt">&#915;</span> is a <span class="stt">Context</span>,
that <span class="stt">goal</span> is a <span class="stt">Prop</span>, and that <span class="stt">tac</span> is a <span class="stt">SynTactic</span> that we can apply to a <span class="stt">Context</span>
to get a <span class="stt">Prop</span>.</p><p>Therefore, for our tactic, we want to throw an error if we can&rsquo;t check as the input. But we know what the
input needs to be: the result of <span class="stt">tac</span>.</p><p><div class="SIntrapara">So:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">chk : SynTactic -&gt; ChkTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *conversion rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given that t is a witness of the proposition P,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">then t is also able to be checked as a witness of P.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk</span><span class="hspace">&nbsp;</span><span class="RktSym">tac</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic?</span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">chk-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">chk</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">goal</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="RktStxLink" data-pltdoc="x">define</a></span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tac</span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">assert-prop-equal!</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="hspace">&nbsp;</span><span class="RktSym">goal</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">where we use the wishlist method to get <span class="stt">assert-prop-equal! : Prop Prop -&gt; Void</span>, which does what it
says on the tin. You will implement this function in assignment 1.</div></p><p>To go the other direction and make a function <span class="stt">imbue</span> that takes a <span class="stt">ChkTactic</span> and returns a
<span class="stt">SynTactic</span>, note that we have an unknown: we aren&rsquo;t able to use a <span class="stt">ChkTactic</span> without a proposition.
So, we add a proposition as an argument, and our signature is <span class="stt">imbue : ChkTactic Prop -&gt; SynTactic</span>.</p><p><div class="SIntrapara">So, purpose statement, contract, template:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">imbue : ChkTactic Prop -&gt; SynTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *annotation rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given that t can check as the proposition P,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">allows t to be imbued with being a witness of P.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">imbue</span><span class="hspace">&nbsp;</span><span class="RktSym">tac</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk-tactic?</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/data-structure-contracts.html#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._any%2Fc%29%29" class="RktValLink" data-pltdoc="x">any/c</a></span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">syn-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">imbue</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/stx-patterns.html#%28form._%28%28lib._racket%2Fprivate%2Fstxcase-scheme..rkt%29._......%29%29" class="RktStxLink" data-pltdoc="x">...</a></span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">We write <span class="RktSym"><a href="https://docs.racket-lang.org/reference/data-structure-contracts.html#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._any%2Fc%29%29" class="RktValLink" data-pltdoc="x">any/c</a></span> for brevity&rsquo;s sake.</div></p><p><span class="stt">tac</span> is a <span class="stt">ChkTactic</span>, which performs a side effect to determine if it checks as the input proposition.
So, we have a <span class="stt">Context</span> <span class="stt">&#915;</span>, and we have a <span class="stt">Prop</span> <span class="stt">prop</span>. Consequently, <span class="RktPn">(</span><span class="RktSym">tac</span><span class="stt"> </span><span class="RktSym">&#915;</span><span class="stt"> </span><span class="RktSym">prop</span><span class="RktPn">)</span>
will run <span class="stt">tac</span> on the context and proposition we have as known variables, and then error if there&rsquo;s an issue.</p><p>Finally, since <span class="RktPn">(</span><span class="RktSym">tac</span><span class="stt"> </span><span class="RktSym">&#915;</span><span class="stt"> </span><span class="RktSym">prop</span><span class="RktPn">)</span> returns <span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span>, and we&rsquo;re creating a <span class="stt">SynTactic</span>, we still need
to return a proposition that our new tactic is a witness of. This is merely <span class="stt">prop</span>.</p><p><div class="SIntrapara">So, our final code is:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">imbue : ChkTactic Prop -&gt; SynTactic</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">Implements the *annotation rule*,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">which, given that t can check as the proposition P,</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">allows t to be imbued with being a witness of P.</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/attaching-contracts-to-values.html#%28form._%28%28lib._racket%2Fcontract%2Fregion..rkt%29._define%2Fcontract%29%29" class="RktStxLink" data-pltdoc="x">define/contract</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">imbue</span><span class="hspace">&nbsp;</span><span class="RktSym">tac</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">chk-tactic?</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/data-structure-contracts.html#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._any%2Fc%29%29" class="RktValLink" data-pltdoc="x">any/c</a></span><span class="hspace">&nbsp;</span><span class="RktPn">. </span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/function-contracts.html#%28form._%28%28lib._racket%2Fcontract%2Fbase..rkt%29._-~3e%29%29" class="RktStxLink" data-pltdoc="x"><span class="nobreak">-&gt;</span></a></span><span class="RktPn"> .</span><span class="hspace">&nbsp;</span><span class="RktSym">syn-tactic?</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">syn-tactic</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktVal">'</span><span class="RktVal">imbue</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._~ce~bb%29%29" class="RktStxLink" data-pltdoc="x">&#955;</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">&#915;</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">tac</span><span class="hspace">&nbsp;</span><span class="RktSym">&#915;</span><span class="hspace">&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktSym">prop</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote></div></p><p>We do not add tests to <span class="stt">imbue</span> yet, because we have no good <span class="stt">ChkTactic</span>s to test with.</p><h4>2.3<tt>&nbsp;</tt><a name="(part._.Elaboration)"></a>Elaboration</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}</div></p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Syllabus.html" title="backward to &quot;1 Syllabus&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;B629 Spring 2023 -- Proofs as Programs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Assignments.html" title="forward to &quot;3 Assignments&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>