<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>4&nbsp;Assignments</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {document.write('<scr' + 'ipt type="text/javascript" src="MathJax/MathJax.js?config=default"></scr' + 'ipt>');})();
</script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">B629 Spring 2023 &ndash; Proofs as Programs</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Course_calendar.html" class="tocviewlink" data-pltdoc="x">Course calendar</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Lecture_notes.html" class="tocviewlink" data-pltdoc="x">Lecture notes</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Assignments</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="Worksheets.html" class="tocviewlink" data-pltdoc="x">Worksheets</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>4&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Assignments</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">4.1&nbsp;</td><td><a href="#%28part._.Assignment_1__.Intuitionistic_propositional_logic%29" class="tocviewlink" data-pltdoc="x">Assignment 1:<span class="mywbr"> &nbsp;</span> Intuitionistic propositional logic</a></td></tr><tr><td align="right">4.2&nbsp;</td><td><a href="#%28part._.Assignment_2__.Simply_typed_lambda_calculus%29" class="tocviewlink" data-pltdoc="x">Assignment 2:<span class="mywbr"> &nbsp;</span> Simply typed lambda calculus</a></td></tr><tr><td align="right">4.3&nbsp;</td><td><a href="#%28part._.Assignment_3__.Normalization_by_evaluation%29" class="tocviewlink" data-pltdoc="x">Assignment 3:<span class="mywbr"> &nbsp;</span> Normalization by evaluation</a></td></tr><tr><td align="right">4.4&nbsp;</td><td><a href="#%28part._.Assignment_4__.Dependent_types%29" class="tocviewlink" data-pltdoc="x">Assignment 4:<span class="mywbr"> &nbsp;</span> Dependent types</a></td></tr><tr><td align="right">4.5&nbsp;</td><td><a href="#%28part._.Assignment_5__.Dependenter_types%29" class="tocviewlink" data-pltdoc="x">Assignment 5:<span class="mywbr"> &nbsp;</span> Dependenter types</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#%28part._.Assignment_1__.Intuitionistic_propositional_logic%29" class="tocsubseclink" data-pltdoc="x">Assignment 1:<span class="mywbr"> &nbsp;</span> Intuitionistic propositional logic</a></td></tr><tr><td><span class="tocsublinknumber">4.2<tt>&nbsp;</tt></span><a href="#%28part._.Assignment_2__.Simply_typed_lambda_calculus%29" class="tocsubseclink" data-pltdoc="x">Assignment 2:<span class="mywbr"> &nbsp;</span> Simply typed lambda calculus</a></td></tr><tr><td><span class="tocsublinknumber">4.3<tt>&nbsp;</tt></span><a href="#%28part._.Assignment_3__.Normalization_by_evaluation%29" class="tocsubseclink" data-pltdoc="x">Assignment 3:<span class="mywbr"> &nbsp;</span> Normalization by evaluation</a></td></tr><tr><td><span class="tocsublinknumber">4.4<tt>&nbsp;</tt></span><a href="#%28part._.Assignment_4__.Dependent_types%29" class="tocsubseclink" data-pltdoc="x">Assignment 4:<span class="mywbr"> &nbsp;</span> Dependent types</a></td></tr><tr><td><span class="tocsublinknumber">4.5<tt>&nbsp;</tt></span><a href="#%28part._.Assignment_5__.Dependenter_types%29" class="tocsubseclink" data-pltdoc="x">Assignment 5:<span class="mywbr"> &nbsp;</span> Dependenter types</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.7.0.8</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Lecture_notes.html" title="backward to &quot;3 Lecture notes&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;B629 Spring 2023 -- Proofs as Programs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Worksheets.html" title="forward to &quot;5 Worksheets&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>4<tt>&nbsp;</tt><a name="(part._.Assignments)"></a>Assignments</h3><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Assignment_1__.Intuitionistic_propositional_logic%29" class="toclink" data-pltdoc="x">4.1<span class="hspace">&nbsp;</span>Assignment 1: Intuitionistic propositional logic</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Assignment_2__.Simply_typed_lambda_calculus%29" class="toclink" data-pltdoc="x">4.2<span class="hspace">&nbsp;</span>Assignment 2: Simply typed lambda calculus</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Assignment_3__.Normalization_by_evaluation%29" class="toclink" data-pltdoc="x">4.3<span class="hspace">&nbsp;</span>Assignment 3: Normalization by evaluation</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Assignment_4__.Dependent_types%29" class="toclink" data-pltdoc="x">4.4<span class="hspace">&nbsp;</span>Assignment 4: Dependent types</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Assignment_5__.Dependenter_types%29" class="toclink" data-pltdoc="x">4.5<span class="hspace">&nbsp;</span>Assignment 5: Dependenter types</a></p></td></tr></table><h4>4.1<tt>&nbsp;</tt><a name="(part._.Assignment_1__.Intuitionistic_propositional_logic)"></a>Assignment 1: Intuitionistic propositional logic</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}
\newcommand{\fst}[1]{\mathsf{fst\ } #1}
\newcommand{\snd}[1]{\mathsf{snd\ } #1}</div></p><p>This assignment will be assigned on January 17th, 2023, and will be due on January 31, 2023.
Corrections will be accepted until February 14, 2023.</p><p>The purpose of this assignment is to create a rudimentary proof assistant for IPL, looking
similar to our existing proof-trees except bottom-up instead of top-down.</p><p>The starting code is available <a href="starter/prop.rkt">here</a>, or on GitHub Classroom if
you are not auditing the course.</p><p>All of your functions should have a good amount of tests. We provide the macros
<span class="stt">check-success</span> (which makes sure that a procedure does not error, but does not check its output)
and <span class="stt">check-error</span> (which makes sure that a procedure errors).</p><p><span style="font-weight: bold">Exercise 1:</span> <span style="font-weight: bold">Design</span> a function <span class="stt">prop=? : Prop Prop -&gt; Boolean</span> that determines
if two <span class="stt">Prop</span>s are equal. Do <span style="font-style: italic">not</span> use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/Equality.html#%28def._%28%28quote._~23~25kernel%29._equal~3f%29%29" class="RktValLink" data-pltdoc="x">equal?</a></span>, instead use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span>
or <span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%2A%29%29" class="RktStxLink" data-pltdoc="x">match*</a></span>.</p><p><span style="font-weight: bold">Exercise 2:</span> Design a tactic combinator
<span class="stt">modus-ponens : SynTactic ChkTactic -&gt; SynTactic</span>, which implements <span style="font-style: italic">&#8594;-elimination</span>:
<div class="math">\ir{}{P \to Q~~ P}{Q}</div>
so, given a witness of <span class="math">P \to Q</span> and a witness checking as <span class="math">P</span>, we get a witness of <span class="math">Q</span>.</p><p><span style="font-style: italic">Hint:</span> Match on the result of the <span class="math">P \to Q</span> tactic, and <span class="stt">throw-proof-error!</span> if
it&rsquo;s wrong. If the so-called witness of <span class="math">P \to Q</span> ends up being a witness of something else,
we can&rsquo;t do anything!</p><p><span style="font-weight: bold">Exercise 3:</span> Design a tactic combinator <span class="stt">conjoin : ChkTactic ChkTactic -&gt; ChkTactic</span>,
which implements <span style="font-style: italic">&#8743;-introduction</span>:
<div class="math">\ir{}{P ~~ Q}{P \land Q}</div>
so, given a witness checking as <span class="math">P</span> and a witness checking as <span class="math">Q</span>, we get a witness of
<span class="math">P \land Q</span>.</p><p><span style="font-style: italic">Hint:</span> Match on the goal, and throw an error if it&rsquo;s wrong. If someone tries to make
<span class="stt">conjoin</span> produce something that&rsquo;s not a conjunction, we can&rsquo;t do anything!</p><p><span style="font-weight: bold">Exercise 4:</span> Design tactic combinators <span class="stt">fst, snd : SynTactic -&gt; SynTactic</span>, which
implement both forms of <span style="font-style: italic">&#8743;-elimination</span> respectively:
<div class="math">\ir{}{P \land Q}{P} ~~ \ir{}{P \land Q}{Q}</div>
so, given a witness of <span class="math">P \land Q</span>, <span class="stt">fst</span> gives you a witness of <span class="math">P</span>, and <span class="stt">snd</span>
gives you a witness of <span class="math">Q</span>.</p><p><span style="font-weight: bold">Exercise 5:</span> Design a tactic combinator <span class="stt">introduce : Symbol ChkTactic -&gt; ChkTactic</span>
which implements <span style="font-style: italic">&#8594;-introduction</span> (no Gentzen-style rule!). Given a name for a witness
of <span class="math">P</span> and a tactic which, given a witness of <span class="math">P</span> in the context, can produce a witness
checking as <span class="math">Q</span>, we should get a witness checking as <span class="math">P \to Q</span>.</p><p><span style="font-style: italic">Hint:</span> Remember implementing <span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span> in your representation-independent
311-style interpreter? You will need to extend the context similarly.</p><p><span style="font-weight: bold">Exercise 6:</span> Use your tactics and <span class="stt">run-chk</span> to prove the proposition
<span class="math">A \to (A \land A)</span>. How does your proof compare to your proof on paper?</p><p><span style="font-weight: bold">Exercise 7:</span> Use your tactics and <span class="stt">run-chk</span> to prove the proposition
<span class="math">(A \to B) \to ((B \to \bot) \to (A \to \bot))</span>, or in other words,
<span class="math">(A \to B) \to (\neg B \to \neg A)</span>.
How does your proof compare to your proof on paper?
Why can we do this, despite not having written any tactics to handle <span class="math">\bot</span>?</p><p><span style="font-weight: bold">Exercise 8:</span> Design a tactic combinator <span class="stt">explode : SynTactic -&gt; ChkTactic</span>, which
implements <span style="font-style: italic">ex falso</span>:
<div class="math">\ir{}{\bot}{A}</div>
so, given a witness of <span class="math">\bot</span>, give us a witness that checks as <span style="font-style: italic">anything</span>.</p><p><span style="font-style: italic">Hint:</span> Use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span>.</p><p><span style="font-weight: bold">Exercise 9:</span> Use your tactics and <span class="stt">run-chk</span> to prove the proposition
<span class="math">(A \land (A \to \bot)) \to B</span>, or in other words, <span class="math">(A \land \neg A) \to B</span>. How does your
proof compare to your proof on paper?</p><p><span style="font-weight: bold">Exercise 10:</span> Design tactic combinators
<span class="stt">left-weaken, right-weaken : ChkTactic -&gt; ChkTactic</span> which implement both forms of
<span style="font-style: italic">&#8744;-introduction</span>, respectively:
<div class="math">\ir{}{P}{P \lor Q} ~~ \ir{}{Q}{P \lor Q}</div>
so, given a witness checking as <span class="stt">P</span>, <span class="stt">left-weaken</span> gives us a witness checking as
<span class="stt">P \lor Q</span>, and given a witness of <span class="stt">Q</span>, <span class="stt">right-weaken</span> gives us a witness checking
as <span class="stt">Q</span>.</p><p><span style="font-weight: bold">Exercise 11:</span> Design a tactic combinator
<span class="stt">cases : ChkTactic SynTactic SynTactic -&gt; SynTactic</span>, which implements <span style="font-style: italic">&#8744;-elimination</span>:
<div class="math">\ir{}{P \lor Q ~~ P \to R ~~ Q \to R}{R}</div>
so, given a witness of <span class="math">P \lor Q</span>, a witness of <span class="math">P \to R</span>, and a witness of <span class="math">Q \to R</span>,
we get a witness of <span class="math">R</span>.</p><p><span style="font-style: italic">Hint:</span> Use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%2A%29%29" class="RktStxLink" data-pltdoc="x">match*</a></span>, or <span class="stt">assert-prop-equal!</span>. Note that the pattern
<span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktSym">a</span><span class="stt"> </span><span class="RktSym">a</span><span class="RktPn">)</span> matches <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span>, but not <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktVal">3</span><span class="RktPn">)</span>.</p><p><span style="font-weight: bold">Exercise 12:</span> Use your tactics and <span class="stt">run-chk</span> to prove the proposition
<span class="math">(A \to B) \to ((A \lor C) \to (B \lor C))</span>. How does your proof compare to your proof on
paper?</p><p><span style="font-style: italic">Hint:</span> You will need to use <span class="stt">imbue</span>.</p><p><span style="font-weight: bold">Exercise 13:</span> Use your tactics and <span class="stt">run-chk</span> to prove the proposition
<span class="math">\neg \neg (A \lor \neg A)</span> (otherwise known as <span class="math">\neg \neg \mathsf{LEM}</span>, the double
negation of the law of excluded middle.) How does your proof compare to your proof on paper?</p><p>The challenge exercises are optional and not required for anyone, but may be instructive or
useful for future assignments.</p><p><span style="font-weight: bold">Challenge exercise 1:</span> Design a tactic combinator <span class="stt">dne : SynTactic -&gt; SynTactic</span>
which, given a witness of <span class="math">\neg \neg A</span>, gives you a witness of <span class="math">A</span>.</p><p><div class="SIntrapara"><span style="font-weight: bold">Challenge exercise 2:</span> Design a tactic <span class="stt">unleash-hole! : ChkTactic</span>, which checks
as any proposition and prints:
</div><div class="SIntrapara"><ul><li><p>the goal proposition,</p></li><li><p>and the current set of assumptions.</p></li></ul></div></p><h4>4.2<tt>&nbsp;</tt><a name="(part._.Assignment_2__.Simply_typed_lambda_calculus)"></a>Assignment 2: Simply typed lambda calculus</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}
\newcommand{\fst}[1]{\mathsf{fst\ } #1}
\newcommand{\snd}[1]{\mathsf{snd\ } #1}</div></p><p>This assignment will be assigned on January 31, 2023, and will be due on February 6, 2023.
Corrections will be accepted until February 20th, 2023.</p><p>The purpose of this assignment is to create an elaborating type checker for the simply-typed
lambda calculus by extending our proof checker for propositional logic. This change is relatively
short, but requires lots of mechanical work.</p><p>The starting code is available <a href="starter/stlc.rkt">here</a>.</p><p>The term builder is not necessary to do this assignment, and requires significant extension if you
wish to use it.</p><p><span style="font-weight: bold">Exercise 1:</span> <span class="stt">s/prop/type/g</span>. Now that we&rsquo;re doing type checking, take your A1 code
and rename the functions and data definitions <span style="font-style: italic">consistently</span> as follows:</p><ul><li><p><span class="stt">throw-proof-error!</span> becomes <span class="stt">throw-type-error!</span></p></li><li><p><span class="stt">Proposition</span>/<span class="stt">Prop</span> becomes <span class="stt">Type</span></p></li><li><p>The <span class="stt">Proposition</span> structures change as according to the starter code</p></li><li><p><span class="stt">prop=?</span> becomes <span class="stt">type=?</span></p></li><li><p><span class="stt">introduce</span> becomes <span class="stt">intro</span></p></li><li><p><span class="stt">imbue</span> becomes <span class="stt">ann</span></p></li><li><p><span class="stt">assumption</span> becomes <span class="stt">var</span></p></li><li><p><span class="stt">modus-ponens</span> becomes <span class="stt">app</span></p></li><li><p><span class="stt">conjoin</span> becomes <span class="stt">cons^</span></p></li><li><p><span class="stt">left-weaken</span> becomes <span class="stt">inl</span></p></li><li><p><span class="stt">right-weaken</span> becomes <span class="stt">inr</span></p></li><li><p><span class="stt">cases</span> becomes <span class="stt">+-elim</span></p></li><li><p><span class="stt">explode</span> becomes <span class="stt">&#8869;-elim</span></p></li></ul><p><span style="font-weight: bold">Exercise 2:</span> <span style="font-style: italic">Building our syntax.</span> For every one of our old <span class="stt">ChkTactic</span>s, return
its corresponding syntax. For every one of our old <span class="stt">SynTactic</span>s, return a pair of the type the term
gives as well as the corresponding syntax. Again, this is detailed in the data definition.</p><p><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match-define%29%29" class="RktStxLink" data-pltdoc="x">match-define</a></span> may be useful to extract things from the result of <span class="stt">SynTactic</span>s in one line.</p><p>Also note that we have a <span class="stt">syntax-ann</span> node, which was not present in our lecture notes.</p><p>Remember to write plenty of tests. Your old <span class="stt">check-success</span> invocations will need to be changed to
<span class="stt">check-equal?</span>, as we are no longer returning <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span>.</p><p><span style="font-weight: bold">Exercise 3:</span> <span style="font-style: italic">Term checking.</span> Design functions <span class="stt">type-check : ConcreteSyntax -&gt; ChkTactic</span>
and <span class="stt">type-infer : ConcreteSyntax -&gt; SynTactic</span> which construct the tactic corresponding to their input
term.</p><p>To write tests for these, you will have to invoke <span class="stt">run-chk</span> and <span class="stt">run-syn</span> on the result of these
functions, and check <span style="font-style: italic">that</span>.</p><p>Also note that each piece of syntax corresponds to exactly one tactic, and some will appear only in
<span class="stt">type-check</span>. Read off your signatures to know what you return. The only place where <span class="stt">chk</span> should
be called is at the very end of <span class="stt">type-check</span>, and nowhere else.</p><p><span style="font-weight: bold">Exercise 4:</span> <span style="font-style: italic">n-ary application.</span> As an example of what elaboration is capable of, design
tactic combinators <span class="stt">intros : [ListOf Symbol] ChkTactic -&gt; ChkTactic</span> and
<span class="stt">apps : SynTactic [ListOf ChkTactic] -&gt; SynTactic</span> which, respectively, do n-ary lambda introduction
and n-ary application. They should elaborate to unary lambda/apply.</p><p>These types of tactic combinators, known as tacticals, can and <span style="font-style: italic">should</span> call <span class="stt">intro</span> and
<span class="stt">app</span>, respectively.</p><p>Then, change <span class="stt">type-check</span> and <span class="stt">type-synth</span> to call these rather than <span class="stt">intro</span>/<span class="stt">app</span>.</p><p><div class="SIntrapara">To do this, change your data definition for concrete syntax to be:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A ConcreteSyntax is one of:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">...</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (cs-lam [ListOf Symbol] ConcreteSyntax)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (cs-app ConcreteSyntax [ListOf ConcreteSyntax])</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">...</span></td></tr></table></blockquote></div></p><p><span style="font-weight: bold">Exercise 5:</span> <span style="font-style: italic">Tying it all up.</span> Take the proofs from <span style="font-weight: bold">Exercise 6</span>, <span style="font-weight: bold">Exercise 7</span>,
<span style="font-weight: bold">Exercise 9</span>, <span style="font-weight: bold">Exercise 12</span>, and <span style="font-weight: bold">Exercise 13</span> of Assignment 1, and turn them into concrete
syntax terms.</p><p>The challenge exercises are optional and not required for anyone, but may be instructive or
useful for future assignments.</p><p><span style="font-weight: bold">Challenge exercise 1:</span> Update your <span class="stt">unleash-hole! : ChkTactic</span> to now be
<span class="stt">unleash-hole : [Maybe SynTactic] -&gt; ChkTactic</span>, which, if it is given a <span class="stt">SynTactic</span> as input,
runs that <span class="stt">SynTactic</span> and prints the type that it proves <span style="font-style: italic">without</span> checking if it matches what is
required. Use the <span class="stt">syntax-hole</span> node as the piece of syntax to return.</p><p>Then, add it to <span class="stt">type-check</span>, using the <span class="stt">cs-hole</span> node.</p><p>As an example, checking the term <span class="stt">(lambda (x) (! x))</span> (where <span class="stt">!</span> represents a hole) should say that the
hole has type <span class="math">A</span>, even if we want to check it as <span class="math">A \to B</span>.</p><h4>4.3<tt>&nbsp;</tt><a name="(part._.Assignment_3__.Normalization_by_evaluation)"></a>Assignment 3: Normalization by evaluation</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}
\newcommand{\fst}[1]{\mathsf{fst\ } #1}
\newcommand{\snd}[1]{\mathsf{snd\ } #1}</div></p><p>This assignment will be assigned on February 7, 2023, and will be due on February <span style="font-weight: bold">17</span>, 2023.
Corrections will be accepted until <span style="font-weight: bold">March 3</span>, 2023.</p><p>The purpose of this assignment is to extend your work for A2, and normalize the core terms that
come out of your elaborating type checker. This change requires a lot of mechanical work, and also
requires computation and possibly uniqueness rules.</p><p>In lecture, we presented the following rules for function types:
<div class="math">\ir{(\to_\beta)}
   {\Gamma, x : A \vdash b : B ~~~ \Gamma \vdash a : A}
   {\Gamma \vdash (\lambda x. b)\ a = b[x/a] : B}
~~~
\ir{(\to_\eta)}
   {\Gamma \vdash f : A \to B}
   {\Gamma \vdash f = (\lambda x. f x) : A \to B}</div></p><p>In the rest of this, we will be extending our normalizer to handle computation and uniqueness rules
for each of our types in A2. We start with our A2 code, and add the normalizer in the starter code,
available <a href="starter/nbe.rkt">here</a>.</p><p><span style="font-weight: bold">Exercise 0:</span> <span style="font-style: italic">Products (done in class).</span> We add a computation rule to our system for products,
but not a uniqueness rule. Note that we <span style="font-style: italic">could</span> add a uniqueness rule, but we do not.</p><p><div class="math">\ir{(\times_{\beta_1})}
   {\Gamma \vdash a : A ~~~ \Gamma \vdash b : B}
   {\Gamma \vdash \mathrm{fst}\ (\mathrm{cons}\ a\ b) = a : A}
~~~
\ir{(\times_{\beta_2})}
   {\Gamma \vdash a : A ~~~ \Gamma \vdash b : B}
   {\Gamma \vdash \mathrm{snd}\ (\mathrm{cons}\ a\ b) = b : B}</div></p><p>Extend <span class="stt">evaluate</span> to produce the new <span class="stt">value-cons</span> node. To do this, match on <span class="stt">syntax-cons</span>,
thereby producing a <span class="stt">value-cons</span> node.</p><p>Then, to support <span class="stt">syntax-fst</span> and <span class="stt">syntax-snd</span>, design functions <span class="stt">do-fst : Value -&gt; Value</span>
and <span class="stt">do-snd : Value -&gt; Value</span> that account for all relevant <span class="stt">Value</span>s (so, <span class="stt">Cut</span>s and <span class="stt">value-cons</span>).
When encountering a neutral, push <span class="stt">value-fst</span> and <span class="stt">value-snd</span> onto the spine.</p><p>Then, extend <span class="stt">reify</span> to account for it as well, modifying <span class="stt">reify-form</span> and <span class="stt">reify</span>. Make sure to
preserve type information throughout your cuts.</p><p><span style="font-weight: bold">Exercise 1:</span> <span style="font-style: italic">Motives.</span> Note that our <span class="stt">Syntax</span> and <span class="stt">Value</span> data definitions have changed
slightly from those in class. In particular, <span class="stt">syntax-+-elim</span> now has a <span class="stt">motive</span> field, which is a
<span style="font-style: italic">type</span>. It represents the type we are eliminating into: for example, if the result of <span class="stt">syntax-+-elim</span>
is <span class="math">C</span> and you&rsquo;re eliminating an <span class="math">A + B</span>, then the motive argument is <span class="math">C</span> and the function types
would be <span class="math">A \to C</span> and <span class="math">B \to C</span>.</p><p>Don&rsquo;t change your <span class="stt">ConcreteSyntax</span> data definition: instead, in the tactics handling <span class="stt">+-elim</span> and
<span class="stt">&#8869;-elim</span>, add the motive as an argument during elaboration. So, if the tactic returns a <span class="math">C</span>, put that
<span class="math">C</span> in the resultant syntax as well.</p><p><span style="font-weight: bold">Exercise 2:</span> <span style="font-style: italic">Sums.</span> Here&rsquo;s the computation rules (again, no uniqueness) for sums:</p><p><div class="math">\ir{(+_{\beta_1})}
   {\Gamma \vdash f : A \to C ~~~ \Gamma \vdash g : B \to C ~~~ \Gamma \vdash a : A}
   {\Gamma \vdash \mathrm{+-elim}\ C\ (\mathrm{inl}\ a)\ f\ g = f\ a : C}
~~~
\ir{(+_{\beta_2})}
   {\Gamma \vdash f : A \to C ~~~ \Gamma \vdash g : B \to C ~~~ \Gamma \vdash b : B}
   {\Gamma \vdash \mathrm{+-elim}\ C\ (\mathrm{inr}\ b)\ f\ g = g\ b : C}</div></p><p>Again, extend <span class="stt">evaluate</span> and <span class="stt">reify</span> to handle <span class="stt">syntax-inl</span> and <span class="stt">syntax-inr</span>. Then, design a function
<span class="stt">do-+-elim : Value Value Value -&gt; Value</span> accounting for all relevant <span class="stt">Value</span>s. When encountering a neutral,
push <span class="stt">value-+-elim</span> onto the spine.</p><p>Note that <span class="stt">value-+-elim</span> takes <span style="font-style: italic">four</span> arguments: the types for <span class="math">f</span> and <span class="math">g</span> in the above rules,
and <span class="math">f</span>, <span class="math">g</span> themselves. This is because in <span class="stt">reify-form</span>, we need to  have the types for <span class="math">f</span> and
<span class="math">g</span> to recursively call <span class="stt">reify</span>, as we did for application.</p><p><span style="font-weight: bold">Exercise 3:</span> <span style="font-style: italic">Bottom.</span> We have no computation or uniqueness rule for bottom. However, it still
needs to be added to <span class="stt">evaluate</span> and <span class="stt">reify</span>.</p><p>Design a function <span class="stt">do-&#8869;-elim : Type Value -&gt; Value</span> that performs bottom elimination. Note that since
we have no concrete values of type <span class="math">&#8869;</span>, all your scrutine&#233;s will be cuts.</p><p>Again, <span class="stt">value-&#8869;-elim</span> needs a field for the type information &#8212;<wbr></wbr> this time, not because we need to recur
in <span class="stt">reify-form</span>, but because our <span class="stt">syntax-&#8869;-elim</span> <span style="font-style: italic">also</span> needs that type information.</p><p>Then, extend <span class="stt">evaluate</span> and <span class="stt">reify</span>.</p><p><span style="font-weight: bold">Exercise 4:</span> <span style="font-style: italic">Tying the knot.</span> Modify <span class="stt">run-chk</span> and <span class="stt">run-syn</span> to produce a normal form of
the elaborated syntax, rather than the elaborated syntax.</p><h4>4.4<tt>&nbsp;</tt><a name="(part._.Assignment_4__.Dependent_types)"></a>Assignment 4: Dependent types</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}
\newcommand{\fst}[1]{\mathsf{fst\ } #1}
\newcommand{\snd}[1]{\mathsf{snd\ } #1}</div></p><p>This assignment will be assigned on February 21, 2023, and will be due on March 6, 2023. Corrections
will be accepted until March 20, 2023.</p><p>The purpose of this assignment is to extend your work on STLC, and add support for <span class="math">\Pi</span>-types, resulting in
a first brush at Martin-L&#246;f type theory. This requires integrating the type checker from A2 with the normalizer
written in A3.</p><p><span style="font-style: italic">This assignment has many moving parts, and it will become easy to confuse variables.</span> Within the tactic
engine, I recommend naming all your tactic variables <span class="stt">X-tac</span>, all your syntax variables <span class="stt">X-stx</span>, and all
your value variables just <span class="stt">X</span> (for some sensible <span class="stt">X</span>).</p><p>The starter code is available <a href="starter/mltt.rkt">here</a>.</p><p><span style="font-weight: bold">Exercise 0:</span> Remove the code that normalizes your terms from <span class="stt">run-chk</span> and <span class="stt">run-syn</span>. You don&rsquo;t
need that anymore.</p><p><span style="font-weight: bold">Exercise 1:</span> <span style="font-style: italic">We&rsquo;re reviewing your application.</span> We no longer have a clear-cut function type
without closures inside of it. Consequently, preserving the type in <span class="stt">do-app</span> will need to change.</p><p>Recall the (non-bidirectional) elimination rule for <span class="math">\Pi</span>:
<div class="math">\ir{(\Pi_{\mathrm{elim}})}
   {\Gamma \vdash f : \Pi_{(x : A)} B ~~~ \Gamma \vdash t : A}
   {\Gamma \vdash f\ t : B[x/t]}</div>
We represent this substitution notion with a closure, and we apply the closure containing <span class="math">B</span> to <span class="math">t</span>.</p><p>Modify <span class="stt">do-app</span> to handle this, updating the type you match on in the <span class="stt">cut</span> case. Then, use
<span class="stt">apply-closure</span> to get <span class="math">B</span>.</p><p>Finally, modify the <span class="stt">reify</span> case that used to handle <span class="stt">type-arrow</span>, and update it to use <span class="stt">value-&#928;</span>.
Again, you need to use <span class="stt">apply-closure</span> to get <span class="math">B</span> for your recursive call.</p><p><span style="font-weight: bold">Exercise 2:</span> <span style="font-style: italic">Arrows? What arrows?</span> With the removal of a basic arrow type, we also need to change
every time we used to call <span class="stt">type-arrow</span> to <span class="stt">value-&#928;</span>. But <span class="stt">value-&#928;</span> takes a closure, which takes a
<span class="stt">Syntax</span>, and we have a <span class="stt">Value</span>!</p><p><div class="SIntrapara">To do this, we update our data definition of a closure:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A Closure is one of:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (closure Syntax Environment)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (h-closure [Value -&gt; Value])</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">closure</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">term</span><span class="hspace">&nbsp;</span><span class="RktSym">env</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/define-struct.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._struct%29%29" class="RktStxLink" data-pltdoc="x">struct</a></span><span class="hspace">&nbsp;</span><span class="RktSym">h-closure</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">fn</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktPn">#:transparent</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">where we reuse Racket&rsquo;s lexical capture, and represent a closure directly as a function taking a value and
returning a value. This avoids having to call <span class="stt">reify</span> and <span class="stt">evaluate</span> just to construct types with known
values.</div></p><p>Update <span class="stt">apply-closure</span> to handle this notion of closure. Everywhere where you used to use <span class="stt">type-arrow</span>,
update it to use <span class="stt">value-&#928;</span> with this new notion of closure. Again, remember that
<span class="math">A \to B := \Pi_{(\_ : A)} B</span>.</p><p><span style="font-weight: bold">Exercise 3:</span> <span style="font-style: italic">Type-type-type.</span> Add a new case to <span class="stt">reify</span>, matching on <span class="stt">value-Type</span>.
Then, handle every constructor: <span class="math">\Pi</span>, <span class="math">\times</span>, <span class="math">+</span>, <span class="math">\bot</span>, <span class="math">\mathbb{N}</span>, <span class="math">\mathrm{Type}</span>, and cuts.</p><p>Reification for every case except <span class="math">\Pi</span> should be relatively straightforward.
You will need to use the provided helper function <span class="stt">fresh-cut</span> to reify the closure representing <span class="math">B</span> in your
<span class="math">\Pi</span> case.</p><p><span style="font-weight: bold">Sanity check:</span> At this point, you should be able to call <span class="stt">normalize</span> on closed, well-typed <span class="stt">Syntax</span>es.
You should not yet be able to type-check these terms, except by hand to generate test cases for <span class="stt">normalize</span>
and the functions playing into it.</p><p><span style="font-weight: bold">Exercise 4:</span> <span style="font-style: italic">Type tactics.</span> Everywhere you used to take a motive argument, you now need to take
a <span class="stt">ChkTactic</span> that checks as <span class="RktPn">(</span><span class="RktSym">value-Type</span><span class="RktPn">)</span>. Do this.</p><p>Whenever you need to turn that tactic&rsquo;s result from a <span class="stt">Syntax</span> a <span class="stt">Value</span> to return it from a
<span class="stt">SyhTactic</span> or use it in another <span class="stt">ChkTactic</span>, use <span class="stt">eval-with-context</span>.</p><p><span style="font-weight: bold">Exercise 5:</span> <span style="font-style: italic">Baking a pi.</span> In class, we showed the well formedness rules for every type but
<span class="math">\Pi</span>.</p><p>The (bidirectional) well formedness rule for <span class="math">\Pi</span> is more complicated:
<div class="math">\ir{(\Pi_{\mathrm{wf}})}
   {\Gamma \vdash A \Leftarrow \mathrm{Type} ~~~ \Gamma, x : A \vdash B \Leftarrow \mathrm{Type}}
   {\Gamma \vdash \Pi_{(x : A)} B \Rightarrow \mathrm{Type}}</div></p><p>Design a function <span class="stt">&#928;-form : Symbol ChkTactic ChkTactic -&gt; SynTactic</span> that performs this typing
judgment. You will need to use <span class="stt">eval-with-context</span> in order to get <span class="math">A</span> to add to the context.</p><p><span style="font-weight: bold">Exercise 6:</span> <span style="font-style: italic">Eating your pi.</span> In <span class="stt">intro</span> and <span class="stt">app</span>, we used to match on <span class="stt">type-arrow</span>, and
we now need to match on <span class="stt">value-&#928;</span>, which then gives us <span class="math">B</span> as a closure.</p><p>Per the last exercise, generate a fresh cut with <span class="stt">fresh-with-context</span>, and use it to generate <span class="math">B</span>. You will
need to extend the context in <span class="stt">intro</span>.</p><p><span style="font-weight: bold">Sanity check:</span> You should now be able to type-check and normalize the identity function.</p><p><span style="font-weight: bold">Exercise 7:</span> <span style="font-style: italic">Trust the less natural natural recursion.</span> Your starter code contains the ability
to handle <span class="stt">rec&#8469;</span>. Recall the rules for <span class="stt">ind&#8469;</span>:</p><p><div class="math">\ir{(\mathbb{N}_{\mathrm{ind}})}
   {\Gamma \vdash P : \mathbb{N} \to \mathrm{Type} ~~~
    \Gamma \vdash m : \mathbb{N} ~~~
    \Gamma \vdash base : P\ \mathrm{zero} ~~~
    \Gamma \vdash step : \Pi_{(k : \mathbb{N})} P\ k \to P\ (\mathrm{suc}\ k)}
   {\Gamma \vdash \mathrm{ind}_{\mathbb{N}}\ P\ m\ base\ step : P\ m}</div></p><p>Update your data definitions to rename <span class="stt">rec&#8469;</span> to <span class="stt">ind&#8469;</span>.</p><p>Extend the tactic for <span class="stt">rec&#8469;</span> to handle <span class="stt">ind&#8469;</span>, and rename it to <span class="stt">ind&#8469;</span>. You will have to use
the argument to your <span class="stt">h-closure</span> to construct the type of <span class="stt">step</span>.</p><p>Then, extend <span class="stt">do-rec&#8469;</span> to become <span class="stt">do-ind&#8469;</span>, noting that <span class="stt">step</span> now takes two arguments.</p><p>The following exercises are not required for anyone.</p><p><span style="font-weight: bold">Challenge exercise 1:</span> <span style="font-style: italic">We&rsquo;re not providing much assistance, huh?</span> We have a type checker, but not
really a proof assistant. When we did A3, we ripped the holes out of our system.</p><p>Add holes back into your system, and integrate them with the normalizer.</p><p><span style="font-style: italic">Hint:</span> Modify the data definition for <span class="stt">Head</span>.</p><h4>4.5<tt>&nbsp;</tt><a name="(part._.Assignment_5__.Dependenter_types)"></a>Assignment 5: Dependenter types</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}
\newcommand{\fst}[1]{\mathsf{fst\ } #1}
\newcommand{\snd}[1]{\mathsf{snd\ } #1}</div></p><p>This assignment will be assigned on April 11, 2023, and will be due at the latest
possible opportunity.</p><p>The purpose of this assignment is to extend your work on A4 to support sigma types
and identity.</p><p><div class="SIntrapara">This assignment is purposefully less detailed than A4. Remember the checklist for adding new things
to your type system:
</div><div class="SIntrapara"><ul><li><p>Update <span class="stt">evaluate</span> and <span class="stt">reify</span> to handle your new data definitions.</p></li><li><p>Create a tactic combinator for each new form, where each premise (thing above the line) is a tactic argument.</p></li><li><p>Update <span class="stt">type-check</span> and <span class="stt">type-infer</span> to handle your new <span class="stt">ConcreteSyntax</span> data definitions.</p></li><li><p>Test.</p></li></ul></div></p><p>The starter code is available on GitHub Classroom, with the link on Canvas.</p><p><span style="font-style: italic">This assignment is impossible without a completed A4.</span></p><p><span style="font-weight: bold">Exercise 1:</span> <span style="font-style: italic">The cooler sum.</span> We have <span class="stt">+-elim</span> in our old code.
Using the rules below, extend this implementation to implement <span class="stt">ind+</span>.</p><p>This should be relatively routine at this point. Make sure to update every reference to <span class="stt">+-elim</span>, and ensure
you&rsquo;re checking with the new dependent motive and type for <span class="math">f</span> and <span class="math">g</span>.</p><p>Note that the definition of <span class="stt">form-ind+</span> has changed a bit. Namely, we save the type of the <span class="stt">scrut</span> in the
<span class="stt">scrut-tp</span> field, which provides enough information to reconstruct the type. (The same applies for the
<span class="stt">scrut-tp</span> field of <span class="stt">form-ind&#8801;</span> later.)</p><p><span style="font-weight: bold">Exercise 2:</span> <span style="font-style: italic">Just what we needed: more Greek.</span> Using the rules below as a reference, modify
<span class="stt">&#215;-form</span> to become <span class="stt">&#931;-form</span>, and <span class="stt">cons^</span>, <span class="stt">fst</span>, and <span class="stt">snd</span> to handle sigma types. This will look
very similar to the implementation of &#928; types.</p><p><span style="font-style: italic">Hint:</span> You will have to infer the type of <span class="stt">scrut</span> before you can check the type of <span class="stt">mot</span>.</p><p><span style="font-style: italic">Hint:</span> In <span class="stt">snd</span>, you will need to get <span class="stt">fst</span> of your pair. To do this, you&rsquo;ll make a call that
looks like <span class="stt">(eval-with-context (syntax-fst ...) ...)</span>.</p><p><span style="font-weight: bold">Exercise 3:</span> <span style="font-style: italic">A missing rule.</span> Update <span class="stt">reify</span> to handle eta for pairs, as given in the rule
<span class="math">\Sigma_\eta</span> below.</p><p>This will look similar to your implementation for eta for functions, in which you&rsquo;ll generate a cut of type
<span class="stt">A</span>, apply it to <span class="stt">B-clo</span>, and call <span class="stt">do-fst</span> and <span class="stt">do-snd</span>. There will be no matching on <span class="stt">val</span>
after you determine that <span class="stt">tp</span> is a dependent pair type.</p><p><span style="font-weight: bold">Exercise 4:</span> <span style="font-style: italic">Identity crisis.</span> Implement the rules below for identity types. Make sure to update
all moving components: so, normalization, tactics, etc.</p><p><span style="font-style: italic">Hint:</span> You will have to infer the type of <span class="stt">scrut</span> before you can check the type of <span class="stt">mot</span>.</p><p><span style="font-style: italic">Hint:</span> You will have an annoying nest of <span class="stt">do-app</span>s in your <span class="stt">ind&#8801;</span> tactic combinator.</p><p>To help test, <span style="font-style: italic">all</span> of the interesting things we&rsquo;ve proven in class (up until HoTT) should now be
provable. Proving that <span class="math">m + 0 = m</span> and <span class="math">0 + m = m</span> are good tests &#8212;<wbr></wbr> you&rsquo;ll need to implement <span class="stt">ap</span>.
I strongly recommend using the <span class="stt">#lang</span> for testing, though it can be somewhat opaque.</p><p><span style="font-weight: bold">Final type rule reference:</span></p><p>Recall that <span class="math">\Leftarrow</span> represents a check tactic, and <span class="math">\Rightarrow</span> represents an infer tactic.</p><p>I like to remember this by thinking of how the arrow points in or out of the term: for <span class="math">\Rightarrow</span>,
the type is given to us by the term which is why it points out, whereas with <span class="math">\Leftarrow</span> the type points
into the term, as we have to ensure the term has that type.</p><p><span style="font-style: italic">Bidirectional core:</span>
<div class="math">\ir{(\mathrm{Var})}
   {x : A \in \Gamma}
   {\Gamma \vdash x \Rightarrow A}
~~~
\ir{(\mathrm{Ann})}
   {\Gamma \vdash x \Leftarrow A}
   {\Gamma \vdash (x : A) \Rightarrow A}
~~~
\ir{(\mathrm{Conv})}
   {\Gamma \vdash x \Rightarrow A&rsquo; ~~~ \Gamma \vdash A = A&rsquo; : \mathrm{Type}}
   {\Gamma \vdash x \Leftarrow A}</div></p><p><span style="font-style: italic">Type-in-type (inconsistent):</span>
<div class="math">\ir{(\mathrm{Type}_{\mathrm{wf}})}
   {}
   {\Gamma \vdash \mathrm{Type} \Rightarrow \mathrm{Type}}</div></p><p><span style="font-style: italic">Pi types:</span>
<div class="math">\ir{(\Pi_{\mathrm{wf}})}
   {\Gamma \vdash A \Leftarrow \mathrm{Type} ~~~ \Gamma, x : A \vdash B \Leftarrow \mathrm{Type}}
   {\Gamma \vdash \Pi_{(x : A)} B \Rightarrow \mathrm{Type}}</div>
<div class="math">\ir{(\Pi_{\mathrm{intro}})}
   {\Gamma, x : A \vdash b \Leftarrow B}
   {\Gamma \vdash \lambda x. b \Leftarrow \Pi_{(x : A)} B}
~~~
\ir{(\Pi_{\mathrm{elim}})}
   {\Gamma \vdash f \Rightarrow \Pi_{(x : A)} B ~~~ \Gamma \vdash t \Leftarrow A}
   {\Gamma \vdash f\ t \Rightarrow B[x \mapsto t]}</div>
<div class="math">\ir{(\Pi_{\beta})}
   {\Gamma, x : A \vdash b : B ~~~ \Gamma \vdash a : A}
   {\Gamma \vdash (\lambda x. b)\ a = b[x \mapsto a] : B[x \mapsto a]}
~~~
\ir{(\Pi_{\eta})}
   {\Gamma \vdash f : \Pi_{(x : A)} B}
   {\Gamma \vdash f = (\lambda x. f\ x) : \Pi_{(x : A)} B}</div></p><p>Syntactic sugar: <span class="math">A \to B</span> is <span class="math">\Pi_{(\_ : A)} B</span>.</p><p><span style="font-style: italic">Sigma types:</span>
<div class="math">\ir{(\Sigma_{\mathrm{wf}})}
   {\Gamma \vdash A \Leftarrow \mathrm{Type} ~~~ \Gamma, x : A \vdash B \Leftarrow \mathrm{Type}}
   {\Gamma \vdash \Sigma_{(x : A)} B \Rightarrow \mathrm{Type}}</div>
<div class="math">\ir{(\Sigma_{\mathrm{intro}})}
   {\Gamma \vdash a \Leftarrow A ~~~ \Gamma \vdash b \Leftarrow B[x \mapsto a]}
   {\Gamma \vdash (a, b) \Leftarrow \Sigma_{(x : A)} B}</div>
<div class="math">\ir{(\Sigma_{\mathrm{elim0}})}
   {\Gamma \vdash p \Rightarrow \Sigma_{(x : A)} B}
   {\Gamma \vdash \mathrm{fst}\ p \Rightarrow A}
~~~
\ir{(\Sigma_{\mathrm{elim1}})}
   {\Gamma \vdash p \Rightarrow \Sigma_{(x : A)} B}
   {\Gamma \vdash \mathrm{snd}\ p \Rightarrow B[x \mapsto \mathrm{fst}\ p]}</div>
<div class="math">\ir{(\Sigma_{\beta 0})}
   {\Gamma \vdash a : A ~~~ \Gamma \vdash b : B[x \mapsto a]}
   {\Gamma \vdash \mathrm{fst}\ (a, b) = a : A}
~~~
\ir{(\Sigma_{\beta 1})}
   {\Gamma \vdash a : A ~~~ \Gamma \vdash b : B[x \mapsto a]}
   {\Gamma \vdash \mathrm{snd}\ (a, b) = b : B[x \mapsto a]}</div>
<div class="math">\ir{(\Sigma_\eta)}
   {\Gamma \vdash p : \Sigma_{(x : A)} B}
   {\Gamma \vdash p = (\mathrm{fst}\ p, \mathrm{snd}\ p) : \Sigma_{(x : A)} B}</div></p><p>Syntactic sugar: <span class="math">A \times B</span> is <span class="math">\Sigma_{(\_ : A)} B</span>.</p><p><span style="font-style: italic">Identity:</span>
<div class="math">\ir{(\equiv_{\mathrm{wf}})}
   {\Gamma \vdash A \Leftarrow \mathrm{Type} ~~~ \Gamma \vdash a \Leftarrow A ~~~ \Gamma \vdash a&rsquo; \Leftarrow A}
   {\Gamma \vdash a \equiv_A a&rsquo; \Rightarrow \mathrm{Type}}
~~~
\ir{(\equiv_{\mathrm{intro}})}
   {\Gamma \vdash a \Rightarrow A}
   {\Gamma \vdash \mathrm{refl}\ a \Rightarrow a \equiv_A a}</div>
<div class="math">\ir{(\equiv_{\mathrm{ind}})}
   {\Gamma \vdash \mathrm{mot} \Leftarrow \Pi_{(x : A)} \Pi_{(y : A)} (x \equiv_A y) \to \mathrm{Type}
    ~~~
    \Gamma \vdash \mathrm{scrut} \Rightarrow x \equiv_A y
    ~~~
    \Gamma \vdash \mathrm{base} \Leftarrow \Pi_{(x : A)} \mathrm{mot}\ x\ x\ (\mathrm{refl}\ x)}
   {\Gamma \vdash \mathrm{ind}_\equiv\ \mathrm{mot}\ \mathrm{scrut}\ \mathrm{base} \Rightarrow \mathrm{mot}\ x\ y\ \mathrm{scrut}}</div>
<div class="math">\ir{(\equiv_\beta)}
   {\Gamma \vdash \mathrm{mot} : \Pi_{(x : A)} \Pi_{(y : A)} (x \equiv_A y) \to \mathrm{Type}
    ~~~
    \Gamma \vdash \mathrm{base} : \Pi_{(x : A)} \mathrm{mot}\ x\ x\ (\mathrm{refl}\ x)
    ~~~
    \Gamma \vdash a : A}
   {\Gamma \vdash \mathrm{ind}_\equiv\ \mathrm{mot}\ (\mathrm{refl}\ a)\ \mathrm{base} = \mathrm{base}\ a : \mathrm{mot}\ a\ a\ (\mathrm{refl}\ a)}</div></p><p><span style="font-style: italic">Sum types:</span>
<div class="math">\ir{(+_\mathrm{wf})}
   {\Gamma \vdash A \Leftarrow \mathrm{Type} ~~~ \Gamma \vdash B \Leftarrow \mathrm{Type}}
   {\Gamma \vdash A + B \Rightarrow \mathrm{Type}}</div>
<div class="math">\ir{(+_{\mathrm{intro}0})}
   {\Gamma \vdash a \Leftarrow A}
   {\Gamma \vdash \mathrm{inl}\ a \Leftarrow A+B}
~~~
\ir{(+_{\mathrm{intro}1})}
   {\Gamma \vdash b \Leftarrow B}
   {\Gamma \vdash \mathrm{inr}\ b \Leftarrow A+B}</div>
<div class="math">\ir{(+_\mathrm{ind})}
   {\Gamma \vdash \mathrm{mot} \Leftarrow (A + B) \to \mathrm{Type}
    ~~~
    \Gamma \vdash \mathrm{scrut} \Rightarrow A + B
    ~~~
    \Gamma \vdash f \Leftarrow \Pi_{(a : A)} \mathrm{mot}\ (\mathrm{inl}\ a)
    ~~~
    \Gamma \vdash g \Leftarrow \Pi_{(b : B)} \mathrm{mot}\ (\mathrm{inr}\ b)}
   {\Gamma \vdash \mathrm{ind}_+\ \mathrm{mot}\ \mathrm{scrut}\ f\ g \Rightarrow \mathrm{mot}\ \mathrm{scrut}}</div>
<div class="math">\ir{(+_{\beta 0})}
   {\Gamma \vdash \mathrm{mot} : (A + B) \to \mathrm{Type}
    ~~~
    \Gamma \vdash f : \Pi_{(a : A)} \mathrm{mot}\ (\mathrm{inl}\ a)
    ~~~
    \Gamma \vdash g : \Pi_{(b : B)} \mathrm{mot}\ (\mathrm{inr}\ b)
    ~~~
    \Gamma \vdash a : A}
   {\Gamma \vdash \mathrm{ind}_+\ \mathrm{mot}\ (\mathrm{inl}\ a)\ f\ g = f\ a : \mathrm{mot}\ (\mathrm{inl}\ a)}</div>
<div class="math">\ir{(+_{\beta 1})}
   {\Gamma \vdash \mathrm{mot} : (A + B) \to \mathrm{Type}
    ~~~
    \Gamma \vdash f : \Pi_{(a : A)} \mathrm{mot}\ (\mathrm{inl}\ a)
    ~~~
    \Gamma \vdash g : \Pi_{(b : B)} \mathrm{mot}\ (\mathrm{inr}\ b)
    ~~~
    \Gamma \vdash b : B}
   {\Gamma \vdash \mathrm{ind}_+\ \mathrm{mot}\ (\mathrm{inr}\ b)\ f\ g = g\ b : \mathrm{mot}\ (\mathrm{inr}\ b)}</div></p><p><span style="font-style: italic">Bottom type:</span>
<div class="math">\ir{(\bot_{\mathrm{wf}})}
   {}
   {\bot \Rightarrow \mathrm{Type}}
~~~
\ir{(\bot_{\mathrm{elim}})}
   {\Gamma \vdash A \Leftarrow \mathrm{Type} ~~~ \Gamma \vdash b \Leftarrow \bot}
   {\Gamma \vdash \bot_{\mathrm{elim}}\ A\ b \Rightarrow A}</div></p><p>Syntactic sugar: <span class="math">\neg A</span> is <span class="math">A \to \bot</span>. (Not part of our concrete syntax.)</p><p><span style="font-style: italic">Naturals:</span>
<div class="math">\ir{(\mathbb{N}_{\mathrm{wf}})}
   {}
   {\Gamma \vdash \mathbb{N} \Rightarrow \mathrm{Type}}
~~~
\ir{(\mathbb{N}_{\mathrm{zero}})}
   {}
   {\Gamma \vdash \mathrm{zero} \Rightarrow \mathbb{N}}
~~~
\ir{(\mathbb{N}_{\mathrm{suc}})}
   {\Gamma \vdash n \Leftarrow \mathbb{N}}
   {\Gamma \vdash \mathrm{suc}\ n \Rightarrow \mathbb{N}}</div>
<div class="math">\ir{(\mathbb{N}_{\mathrm{ind}})}
   {\Gamma \vdash \mathrm{mot} \Leftarrow \mathbb{N} \to \mathrm{Type} ~~~
    \Gamma \vdash \mathrm{scrut} \Leftarrow \mathbb{N} ~~~
    \Gamma \vdash \mathrm{base} \Leftarrow \mathrm{mot}\ \mathrm{zero} ~~~
    \Gamma \vdash \mathrm{step} \Leftarrow \Pi_{(k : \mathbb{N})} \mathrm{mot}\ k \to \mathrm{mot}\ (\mathrm{suc}\ k)}
   {\Gamma \vdash \mathrm{ind}_{\mathbb{N}}\ \mathrm{mot}\ \mathrm{scrut}\ \mathrm{base}\ \mathrm{step} \Rightarrow \mathrm{mot}\ \mathrm{scrut}}</div>
<div class="math">\ir{(\mathbb{N}_{\beta\mathrm{zero}})}
   {\Gamma \vdash \mathrm{mot} : \mathbb{N} \to \mathrm{Type} ~~~
    \Gamma \vdash \mathrm{base} : \mathrm{mot}\ \mathrm{zero} ~~~
    \Gamma \vdash \mathrm{step} : \Pi_{(k : \mathbb{N})} \mathrm{mot}\ k \to \mathrm{mot}\ (\mathrm{suc}\ k)}
   {\Gamma \vdash \mathrm{ind}_{\mathbb{N}}\ \mathrm{mot}\ \mathrm{zero}\ \mathrm{base}\ \mathrm{step} = \mathrm{base} : \mathrm{mot}\ \mathrm{zero}}</div>
<div class="math">\ir{(\mathbb{N}_{\beta\mathrm{suc}})}
   {\Gamma \vdash \mathrm{mot} : \mathbb{N} \to \mathrm{Type} ~~~
    \Gamma \vdash \mathrm{base} : \mathrm{mot}\ \mathrm{zero} ~~~
    \Gamma \vdash \mathrm{step} : \Pi_{(k : \mathbb{N})} \mathrm{mot}\ k \to \mathrm{mot}\ (\mathrm{suc}\ k) ~~~
    \Gamma \vdash m : \mathbb{N}}
   {\Gamma \vdash \mathrm{ind}_{\mathbb{N}}\ \mathrm{mot}\ (\mathrm{suc}\ m)\ \mathrm{base}\ \mathrm{step} = \mathrm{step}\ (\mathrm{ind}_{\mathbb{N}}\ \mathrm{mot}\ m\ \mathrm{base}\ \mathrm{step}) : \mathrm{mot}\ (\mathrm{suc}\ m)}</div></p><p><span style="font-style: italic">Not included:</span> formation rules (part of the grammar), rules for Tarski universes, "obvious" reductions (not &#946; or &#951;)</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Lecture_notes.html" title="backward to &quot;3 Lecture notes&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;B629 Spring 2023 -- Proofs as Programs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Worksheets.html" title="forward to &quot;5 Worksheets&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>