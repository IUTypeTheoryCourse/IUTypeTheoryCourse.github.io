<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>4&nbsp;Assignments</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {document.write('<scr' + 'ipt type="text/javascript" src="MathJax/MathJax.js?config=default"></scr' + 'ipt>');})();
</script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">B629 Spring 2023 &ndash; Proofs as Programs</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="Syllabus.html" class="tocviewlink" data-pltdoc="x">Syllabus</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="Course_calendar.html" class="tocviewlink" data-pltdoc="x">Course calendar</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Lecture_notes.html" class="tocviewlink" data-pltdoc="x">Lecture notes</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Assignments</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="Worksheets.html" class="tocviewlink" data-pltdoc="x">Worksheets</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>4&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Assignments</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">4.1&nbsp;</td><td><a href="#%28part._.Assignment_1__.Intuitionistic_propositional_logic%29" class="tocviewlink" data-pltdoc="x">Assignment 1:<span class="mywbr"> &nbsp;</span> Intuitionistic propositional logic</a></td></tr><tr><td align="right">4.2&nbsp;</td><td><a href="#%28part._.Assignment_2__.Simply_typed_lambda_calculus%29" class="tocviewlink" data-pltdoc="x">Assignment 2:<span class="mywbr"> &nbsp;</span> Simply typed lambda calculus</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#%28part._.Assignment_1__.Intuitionistic_propositional_logic%29" class="tocsubseclink" data-pltdoc="x">Assignment 1:<span class="mywbr"> &nbsp;</span> Intuitionistic propositional logic</a></td></tr><tr><td><span class="tocsublinknumber">4.2<tt>&nbsp;</tt></span><a href="#%28part._.Assignment_2__.Simply_typed_lambda_calculus%29" class="tocsubseclink" data-pltdoc="x">Assignment 2:<span class="mywbr"> &nbsp;</span> Simply typed lambda calculus</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">8.7.0.8</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Lecture_notes.html" title="backward to &quot;3 Lecture notes&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;B629 Spring 2023 -- Proofs as Programs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Worksheets.html" title="forward to &quot;5 Worksheets&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3>4<tt>&nbsp;</tt><a name="(part._.Assignments)"></a>Assignments</h3><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Assignment_1__.Intuitionistic_propositional_logic%29" class="toclink" data-pltdoc="x">4.1<span class="hspace">&nbsp;</span>Assignment 1: Intuitionistic propositional logic</a></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#%28part._.Assignment_2__.Simply_typed_lambda_calculus%29" class="toclink" data-pltdoc="x">4.2<span class="hspace">&nbsp;</span>Assignment 2: Simply typed lambda calculus</a></p></td></tr></table><h4>4.1<tt>&nbsp;</tt><a name="(part._.Assignment_1__.Intuitionistic_propositional_logic)"></a>Assignment 1: Intuitionistic propositional logic</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}
\newcommand{\fst}[1]{\mathsf{fst\ } #1}
\newcommand{\snd}[1]{\mathsf{snd\ } #1}</div></p><p>This assignment will be assigned on January 17th, 2022, and will be due on January 31, 2022.
Corrections will be accepted until February 14, 2022.</p><p>The purpose of this assignment is to create a rudimentary proof assistant for IPL, looking
similar to our existing proof-trees except bottom-up instead of top-down.</p><p>The starting code is available <a href="starter/prop.rkt">here</a>, or on GitHub Classroom if
you are not auditing the course.</p><p>All of your functions should have a good amount of tests. We provide the macros
<span class="stt">check-success</span> (which makes sure that a procedure does not error, but does not check its output)
and <span class="stt">check-error</span> (which makes sure that a procedure errors).</p><p><span style="font-weight: bold">Exercise 1:</span> <span style="font-weight: bold">Design</span> a function <span class="stt">prop=? : Prop Prop -&gt; Boolean</span> that determines
if two <span class="stt">Prop</span>s are equal. Do <span style="font-style: italic">not</span> use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/Equality.html#%28def._%28%28quote._~23~25kernel%29._equal~3f%29%29" class="RktValLink" data-pltdoc="x">equal?</a></span>, instead use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%29%29" class="RktStxLink" data-pltdoc="x">match</a></span>
or <span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%2A%29%29" class="RktStxLink" data-pltdoc="x">match*</a></span>.</p><p><span style="font-weight: bold">Exercise 2:</span> Design a tactic combinator
<span class="stt">modus-ponens : SynTactic ChkTactic -&gt; SynTactic</span>, which implements <span style="font-style: italic">&#8594;-elimination</span>:
<div class="math">\ir{}{P \to Q~~ P}{Q}</div>
so, given a witness of <span class="math">P \to Q</span> and a witness checking as <span class="math">P</span>, we get a witness of <span class="math">Q</span>.</p><p><span style="font-style: italic">Hint:</span> Match on the result of the <span class="math">P \to Q</span> tactic, and <span class="stt">throw-proof-error!</span> if
it&rsquo;s wrong. If the so-called witness of <span class="math">P \to Q</span> ends up being a witness of something else,
we can&rsquo;t do anything!</p><p><span style="font-weight: bold">Exercise 3:</span> Design a tactic combinator <span class="stt">conjoin : ChkTactic ChkTactic -&gt; ChkTactic</span>,
which implements <span style="font-style: italic">&#8743;-introduction</span>:
<div class="math">\ir{}{P ~~ Q}{P \land Q}</div>
so, given a witness checking as <span class="math">P</span> and a witness checking as <span class="math">Q</span>, we get a witness of
<span class="math">P \land Q</span>.</p><p><span style="font-style: italic">Hint:</span> Match on the goal, and throw an error if it&rsquo;s wrong. If someone tries to make
<span class="stt">conjoin</span> produce something that&rsquo;s not a conjunction, we can&rsquo;t do anything!</p><p><span style="font-weight: bold">Exercise 4:</span> Design tactic combinators <span class="stt">fst, snd : SynTactic -&gt; SynTactic</span>, which
implement both forms of <span style="font-style: italic">&#8743;-elimination</span> respectively:
<div class="math">\ir{}{P \land Q}{P} ~~ \ir{}{P \land Q}{Q}</div>
so, given a witness of <span class="math">P \land Q</span>, <span class="stt">fst</span> gives you a witness of <span class="math">P</span>, and <span class="stt">snd</span>
gives you a witness of <span class="math">Q</span>.</p><p><span style="font-weight: bold">Exercise 5:</span> Design a tactic combinator <span class="stt">introduce : Symbol ChkTactic -&gt; ChkTactic</span>
which implements <span style="font-style: italic">&#8594;-introduction</span> (no Gentzen-style rule!). Given a name for a witness
of <span class="math">P</span> and a tactic which, given a witness of <span class="math">P</span> in the context, can produce a witness
checking as <span class="math">Q</span>, we should get a witness checking as <span class="math">P \to Q</span>.</p><p><span style="font-style: italic">Hint:</span> Remember implementing <span class="RktSym"><a href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" class="RktStxLink" data-pltdoc="x">lambda</a></span> in your representation-independent
311-style interpreter? You will need to extend the context similarly.</p><p><span style="font-weight: bold">Exercise 6:</span> Use your tactics and <span class="stt">run-chk</span> to prove the proposition
<span class="math">A \to (A \land A)</span>. How does your proof compare to your proof on paper?</p><p><span style="font-weight: bold">Exercise 7:</span> Use your tactics and <span class="stt">run-chk</span> to prove the proposition
<span class="math">(A \to B) \to ((B \to \bot) \to (A \to \bot))</span>, or in other words,
<span class="math">(A \to B) \to (\neg B \to \neg A)</span>.
How does your proof compare to your proof on paper?
Why can we do this, despite not having written any tactics to handle <span class="math">\bot</span>?</p><p><span style="font-weight: bold">Exercise 8:</span> Design a tactic combinator <span class="stt">explode : SynTactic -&gt; ChkTactic</span>, which
implements <span style="font-style: italic">ex falso</span>:
<div class="math">\ir{}{\bot}{A}</div>
so, given a witness of <span class="math">\bot</span>, give us a witness that checks as <span style="font-style: italic">anything</span>.</p><p><span style="font-style: italic">Hint:</span> Use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span>.</p><p><span style="font-weight: bold">Exercise 9:</span> Use your tactics and <span class="stt">run-chk</span> to prove the proposition
<span class="math">(A \land (A \to \bot)) \to B</span>, or in other words, <span class="math">(A \land \neg A) \to B</span>. How does your
proof compare to your proof on paper?</p><p><span style="font-weight: bold">Exercise 10:</span> Design tactic combinators
<span class="stt">left-weaken, right-weaken : ChkTactic -&gt; ChkTactic</span> which implement both forms of
<span style="font-style: italic">&#8744;-introduction</span>, respectively:
<div class="math">\ir{}{P}{P \lor Q} ~~ \ir{}{Q}{P \lor Q}</div>
so, given a witness checking as <span class="stt">P</span>, <span class="stt">left-weaken</span> gives us a witness checking as
<span class="stt">P \lor Q</span>, and given a witness of <span class="stt">Q</span>, <span class="stt">right-weaken</span> gives us a witness checking
as <span class="stt">Q</span>.</p><p><span style="font-weight: bold">Exercise 11:</span> Design a tactic combinator
<span class="stt">cases : ChkTactic SynTactic SynTactic -&gt; SynTactic</span>, which implements <span style="font-style: italic">&#8744;-elimination</span>:
<div class="math">\ir{}{P \lor Q ~~ P \to R ~~ Q \to R}{R}</div>
so, given a witness of <span class="math">P \lor Q</span>, a witness of <span class="math">P \to R</span>, and a witness of <span class="math">Q \to R</span>,
we get a witness of <span class="math">R</span>.</p><p><span style="font-style: italic">Hint:</span> Use <span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match%2A%29%29" class="RktStxLink" data-pltdoc="x">match*</a></span>, or <span class="stt">assert-prop-equal!</span>. Note that the pattern
<span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktSym">a</span><span class="stt"> </span><span class="RktSym">a</span><span class="RktPn">)</span> matches <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span>, but not <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._list%29%29" class="RktValLink" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">2</span><span class="stt"> </span><span class="RktVal">3</span><span class="RktPn">)</span>.</p><p><span style="font-weight: bold">Exercise 12:</span> Use your tactics and <span class="stt">run-chk</span> to prove the proposition
<span class="math">(A \to B) \to ((A \lor C) \to (B \lor C))</span>. How does your proof compare to your proof on
paper?</p><p><span style="font-style: italic">Hint:</span> You will need to use <span class="stt">imbue</span>.</p><p><span style="font-weight: bold">Exercise 13:</span> Use your tactics and <span class="stt">run-chk</span> to prove the proposition
<span class="math">\neg \neg (A \lor \neg A)</span> (otherwise known as <span class="math">\neg \neg \mathsf{LEM}</span>, the double
negation of the law of excluded middle.) How does your proof compare to your proof on paper?</p><p>The challenge exercises are optional and not required for anyone, but may be instructive or
useful for future assignments.</p><p><span style="font-weight: bold">Challenge exercise 1:</span> Design a tactic combinator <span class="stt">dne : SynTactic -&gt; SynTactic</span>
which, given a witness of <span class="math">\neg \neg A</span>, gives you a witness of <span class="math">A</span>.</p><p><div class="SIntrapara"><span style="font-weight: bold">Challenge exercise 2:</span> Design a tactic <span class="stt">unleash-hole! : ChkTactic</span>, which checks
as any proposition and prints:
</div><div class="SIntrapara"><ul><li><p>the goal proposition,</p></li><li><p>and the current set of assumptions.</p></li></ul></div></p><h4>4.2<tt>&nbsp;</tt><a name="(part._.Assignment_2__.Simply_typed_lambda_calculus)"></a>Assignment 2: Simply typed lambda calculus</h4><p><div class="math">\newcommand{\ir}[3]{\displaystyle\frac{#2}{#3}~{\textstyle #1}}
\newcommand{\semantics}[1]{[\![ #1 ]\!]}
\newcommand{\fst}[1]{\mathsf{fst\ } #1}
\newcommand{\snd}[1]{\mathsf{snd\ } #1}</div></p><p>This assignment will be assigned on January 31, 2022, and will be due on February 6, 2022.
Corrections will be accepted until February 20th, 2022.</p><p>The purpose of this assignment is to create an elaborating type checker for the simply-typed
lambda calculus by extending our proof checker for propositional logic. This change is relatively
short, but requires lots of mechanical work.</p><p>The starting code is available <a href="starter/stlc.rkt">here</a>.</p><p>The term builder is not necessary to do this assignment, and requires significant extension if you
wish to use it.</p><p><span style="font-weight: bold">Exercise 1:</span> <span class="stt">s/prop/type/g</span>. Now that we&rsquo;re doing type checking, take your A1 code
and rename the functions and data definitions <span style="font-style: italic">consistently</span> as follows:</p><ul><li><p><span class="stt">throw-proof-error!</span> becomes <span class="stt">throw-type-error!</span></p></li><li><p><span class="stt">Proposition</span>/<span class="stt">Prop</span> becomes <span class="stt">Type</span></p></li><li><p>The <span class="stt">Proposition</span> structures change as according to the starter code</p></li><li><p><span class="stt">prop=?</span> becomes <span class="stt">type=?</span></p></li><li><p><span class="stt">introduce</span> becomes <span class="stt">intro</span></p></li><li><p><span class="stt">imbue</span> becomes <span class="stt">ann</span></p></li><li><p><span class="stt">assumption</span> becomes <span class="stt">var</span></p></li><li><p><span class="stt">modus-ponens</span> becomes <span class="stt">app</span></p></li><li><p><span class="stt">conjoin</span> becomes <span class="stt">cons^</span></p></li><li><p><span class="stt">left-weaken</span> becomes <span class="stt">inl</span></p></li><li><p><span class="stt">right-weaken</span> becomes <span class="stt">inr</span></p></li><li><p><span class="stt">cases</span> becomes <span class="stt">+-elim</span></p></li><li><p><span class="stt">explode</span> becomes <span class="stt">&#8869;-elim</span></p></li></ul><p><span style="font-weight: bold">Exercise 2:</span> <span style="font-style: italic">Building our syntax.</span> For every one of our old <span class="stt">ChkTactic</span>s, return
its corresponding syntax. For every one of our old <span class="stt">SynTactic</span>s, return a pair of the type the term
gives as well as the corresponding syntax. Again, this is detailed in the data definition.</p><p><span class="RktSym"><a href="https://docs.racket-lang.org/reference/match.html#%28form._%28%28lib._racket%2Fmatch..rkt%29._match-define%29%29" class="RktStxLink" data-pltdoc="x">match-define</a></span> may be useful to extract things from the result of <span class="stt">SynTactic</span>s in one line.</p><p>Also note that we have a <span class="stt">syntax-ann</span> node, which was not present in our lecture notes.</p><p>Remember to write plenty of tests. Your old <span class="stt">check-success</span> invocations will need to be changed to
<span class="stt">check-equal?</span>, as we are no longer returning <span class="RktPn">(</span><span class="RktSym"><a href="https://docs.racket-lang.org/reference/void.html#%28def._%28%28quote._~23~25kernel%29._void%29%29" class="RktValLink" data-pltdoc="x">void</a></span><span class="RktPn">)</span>.</p><p><span style="font-weight: bold">Exercise 3:</span> <span style="font-style: italic">Term checking.</span> Design functions <span class="stt">type-check : ConcreteSyntax -&gt; ChkTactic</span>
and <span class="stt">type-infer : ConcreteSyntax -&gt; SynTactic</span> which construct the tactic corresponding to their input
term.</p><p>To write tests for these, you will have to invoke <span class="stt">run-chk</span> and <span class="stt">run-syn</span> on the result of these
functions, and check <span style="font-style: italic">that</span>.</p><p>Also note that each piece of syntax corresponds to exactly one tactic, and some will appear only in
<span class="stt">type-check</span>. Read off your signatures to know what you return. The only place where <span class="stt">chk</span> should
be called is at the very end of <span class="stt">type-check</span>, and nowhere else.</p><p><span style="font-weight: bold">Exercise 4:</span> <span style="font-style: italic">n-ary application.</span> As an example of what elaboration is capable of, design
tactic combinators <span class="stt">intros : [ListOf Symbol] ChkTactic -&gt; ChkTactic</span> and
<span class="stt">apps : SynTactic [ListOf ChkTactic] -&gt; SynTactic</span> which, respectively, do n-ary lambda introduction
and n-ary application. They should elaborate to unary lambda/apply.</p><p>These types of tactic combinators, known as tacticals, can and <span style="font-style: italic">should</span> call <span class="stt">intro</span> and
<span class="stt">app</span>, respectively.</p><p>Then, change <span class="stt">type-check</span> and <span class="stt">type-synth</span> to call these rather than <span class="stt">intro</span>/<span class="stt">app</span>.</p><p><div class="SIntrapara">To do this, change your data definition for concrete syntax to be:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">A ConcreteSyntax is one of:</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">...</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (cs-lam [ListOf Symbol] ConcreteSyntax)</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">- (cs-app ConcreteSyntax [ListOf ConcreteSyntax])</span></td></tr><tr><td><span class="RktCmt">;</span><span class="RktCmt">&nbsp;</span><span class="RktCmt">...</span></td></tr></table></blockquote></div></p><p><span style="font-weight: bold">Exercise 5:</span> <span style="font-style: italic">Tying it all up.</span> Take the proofs from <span style="font-weight: bold">Exercise 6</span>, <span style="font-weight: bold">Exercise 7</span>,
<span style="font-weight: bold">Exercise 9</span>, <span style="font-weight: bold">Exercise 12</span>, and <span style="font-weight: bold">Exercise 13</span> of Assignment 1, and turn them into concrete
syntax terms.</p><p>The challenge exercises are optional and not required for anyone, but may be instructive or
useful for future assignments.</p><p><span style="font-weight: bold">Challenge exercise 1:</span> Update your <span class="stt">unleash-hole! : ChkTactic</span> to now be
<span class="stt">unleash-hole : [Maybe SynTactic] -&gt; ChkTactic</span>, which, if it is given a <span class="stt">SynTactic</span> as input,
runs that <span class="stt">SynTactic</span> and prints the type that it proves <span style="font-style: italic">without</span> checking if it matches what is
required. Use the <span class="stt">syntax-hole</span> node as the piece of syntax to return.</p><p>Then, add it to <span class="stt">type-check</span>, using the <span class="stt">cs-hole</span> node.</p><p>As an example, checking the term <span class="stt">(lambda (x) (! x))</span> (where <span class="stt">!</span> represents a hole) should say that the
hole has type <span class="math">A</span>, even if we want to check it as <span class="math">A \to B</span>.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;<span class="tocsettoggle">&nbsp;&nbsp;<a href="javascript:void(0);" title="show/hide table of contents" onclick="TocsetToggle();">contents</a></span></span><span class="navright">&nbsp;&nbsp;<a href="Lecture_notes.html" title="backward to &quot;3 Lecture notes&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;B629 Spring 2023 -- Proofs as Programs&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Worksheets.html" title="forward to &quot;5 Worksheets&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>